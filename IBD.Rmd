---
title: "IBD Network Based Functional Prediction"
author: "Montana Kay Lara"
date: "June 16, 2019"
output: 
  html_document: default
  pdf_document: default
---

This workflow accompanies the paper "Identification of novel loci controlling IBD susceptibility by utilizing the genetic diversity of wild-derived mice." The purpose of this workflow was to prioritize genes in chromosomes 1 and 2, and the Ccc1 locus associated with IBD in mice. 

This workflow incorporates IBD mouse model immune cell transcriptomic data from the Krementsov lab and human IBD GWAS genes (de Lange KM, et al. doi:10.1038/ng.3760). Here we take the GWAS gens to train SVMs using the intestine and hemolymphoid networks from Functional Networks of Tissues in Mice (http://fntm.princeton.edu). We combine the SVM scores and expression data to rank positional candidates contributing to IBD susceptibility. 

UPDATE: June 30, 2020

## Outline

I.    Project Setup
II.   GWAS Genes and ID Conversion
III.  Expression Data
IV.   Gene Positions
V.    Data Cleanup and Consolidation
VI.   SVM
VII.  Integrate Gene Information with SVM Output
VIII. Gene Scores
IX.   Plot value preparation
X.    Plotting Integrated Ranking

## I. Project Setup

A. Packages
```{r setup}
all.packages <- c("tidyverse", 
                  "ggplot2", 
                  "here", 
                  "readxl",
                  "conflicted", 
                  "gprofiler2", 
                  "R.utils", 
                  "doParallel", 
                  "gprofiler2", 
                  "DescTools", 
                  "knitr",
                  "igraph",
                  "magrittr", 
                  "RColorBrewer", 
                  "biomaRt",
                  "hablar", 
                  "plotly",
                  "forcats", 
                  "magrittr",
                  "e1071")
for(i in 1:length(all.packages)){library(all.packages[i], character.only = TRUE)} 
conflict_prefer("filter", "dplyr")
```

B. Directory setup
```{r setup_dir}
project.dir <- here()
code.dir <- here("Code")
data.dir <- here("Data")
results.int.dir <- here("Results_int")
results.hemo.dir <- here("Results_hemo")
```

C. Source the code used in the project
```{r source_code}
all.fun.dir <- list.files(code.dir, full.names = TRUE)
for(i in 1:length(all.fun.dir)){
   all.fun <- list.files(all.fun.dir[i], full.names = TRUE)
    for(j in 1:length(all.fun)){source(all.fun[j])}
    }
```

D. Download networks
Download mouse networks from functional networks of tissues in mice (FNTM). The specified networks used in this analysis were downloaded on July 25, 2019 (then again on June 30, 2020 when updating this workflow). The function download.tissue.network() will download the specified network (top edges) and place it in the specified directory
```{r download_network}
# 1. Intestine 
int.net <- here("Data", "intestine_top.Rdata")
if(!file.exists(int.net)){
    download.tissue.net(tissue = "intestine", organism = "mouse", project.dir = data.dir)
    }

# 2. Hemolymphoid
hemo.net <- here("Data", "hemolymphoid_system_top.Rdata")
if(!file.exists(hemo.net)){
    download.tissue.net(tissue = "hemolymphoid system", organism = "mouse", project.dir = data.dir)
    }
```

E. Read in the downlaoded function genomic network
```{r read_fgn}
# 1. Intestine
intfgn <- readRDS(here("Data", "intestine_top.Rdata"))

# 2. Hemolymphoid
hemofgn <- readRDS(here("Data", "hemolymphoid_system_top.Rdata"))
```

## II.   GWAS Genes and ID Conversion

```{r GWAS_genes}
# import list from excel file
IBDGWASgenes <- read_excel(here("Data", "DE_genes", "IBDGWASgenes.xlsx"), sheet = "IBD GWAS column list")

# convert GWAS genes from human to mouse using gprofiler
IBD.mouse.orth <- gorth(IBDGWASgenes[[1]], source_organism = "hsapiens", target_organism = "mmusculus")

# convert mouse genes to entrez IDs
IBD.gconvert <- gconvert(IBD.mouse.orth$ortholog_name, organism = "mmusculus", target = "ENTREZGENE_ACC")
```

## III.  Expression Data

This workflow incorporates gene expression data from five different immune cells (Krementsov lab). 
A. Read in DEG data
```{r DEG_data}
#read in excel file with differentially expressed genes (DEG) data
DEG.all.original <- read_excel(here("Data", "DE_genes", "Full microarray for Matt - v3.xlsx"), sheet = "v3 2nd dup removal")

#cleanup (NOTE: this is specific to this excel file with the DEGs, and this cleanup will have duplicates because of the nature of the expression data - ie, we won't remove duplicates at this point because lowest expression p values may be in different observations for each immune cell and cleaner filtering can happen later)
DEG.all <- DEG.all.original %>% 
              rename(APCpv = `stepup(p-value(PWD * APCs vs. B6 * APCs))`, 
                     BCELLpv = `stepup(p-value(PWD * Bcells vs. B6 * Bcells))`, 
                     CD4pv = `stepup(p-value(PWD * CD4 vs. B6 * CD4))`, 
                     CD8pv = `stepup(p-value(PWD * CD8 vs. B6 * CD8))`, 
                     TREGpv = `stepup(p-value(PWD * Tregs vs. B6 * Tregs))`,
                     EntrezID = `Entrez Gene ID`,
                     Symbol = `NEW Symbol`) %>% 
              select(Symbol, EntrezID, Chr, APCpv, BCELLpv, CD4pv, CD8pv, TREGpv) %>% 
              mutate(across(starts_with("EntrezID"), as.character))
```

## IV.   Gene Positions

We used biomart to obtain the genomic position and entrez IDs for genes on the Ccc1 locus. First, we set up the mmusculus biomart libary. The library is used to retrive information about gene IDs and genomic position. The function getBM requires attributes to be outputed, filters for the inputed genes, values of the genes we input, and the biomart library. 
```{r Ccc1_genes}
#create mart by selecting biomart database and dataset
mmusculus <- useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl") 
#listAttributes(mmusculus) will give list of all potential attributes to output
#listFilters(mmusculus) will give list of all potential filters for the values

#set genomic region for value inputs
chr <- 12
region.min <- 94800000
region.max <- 112300000
chr.region <- paste(chr, region.min, region.max, sep = ":")

#get position information for all genes in the region
Ccc1.gene.biomart <- getBM(attributes = c("external_gene_name", "entrezgene_id", "start_position", "end_position", "chromosome_name"), 
                        filters = "chromosomal_region", 
                        values = chr.region, 
                        mart = mmusculus)

#make entregene_id characters and take out those genes without entrez ids (and rename column names to match DEG.all)
Ccc1.gene.info <- Ccc1.gene.biomart %>% 
  mutate(across(starts_with("entrezgene_id"), as.character)) %>% 
  filter(!is.na(entrezgene_id)) %>% 
  rename(Symbol = external_gene_name,
         EntrezID = entrezgene_id, 
         Chr = chromosome_name) %>% 
  mutate(across(starts_with("Chr"), as.character))
```

## V.    Data Cleanup and Consolidation

We consolidated gene infomration into a table (DEG.all) with gene expression data and position data. We also filtered for chromosome 1 and 2 (DEG.chr). In addition, this specific dataset has some 0 values for p-values, which will need to be converted to non-zero values to put through this workflow. 
A. Add gene position table with DEG table
```{r DEG.all}
#add Ccc1 to DEG (there are some in Ccc1 entrez genes not in Deg, so filtering later would miss genes)
DEG.all <- bind_rows(DEG.all, Ccc1.gene.info)
```

B. Chromosome 1 and 2 filter
```{r Chr_filter}
#filter chr 1 and 2 (this will make running score.candidates go faster, you can also do all DEG.all)
DEG.chr <- DEG.all %>% 
  filter(Chr == 1 | Chr == 2)
```

C. DEG p-value cleanup
Convert p-values that are 0 to non-zero minimums (to be able to log transform and scale)
```{r DEG_cleanup}
#Finding min non-zero value for each p-value (ONLY from DEG.chr, did not go through entire DEG.all), this may not be necessary for each p-value column
min(DEG.chr$APCpv[DEG.chr$APCpv!=0])
min(DEG.chr$BCELLpv[DEG.chr$BCELLpv!=0])
min(DEG.chr$CD4pv[DEG.chr$CD4pv!=0])
min(DEG.chr$CD8pv[DEG.chr$CD8pv!=0])
min(DEG.chr$TREGpv[DEG.chr$TREGpv!=0])

#replacing 0 values with non-zero mins
DEG.chr %<>%
  mutate(APCpv   = replace(APCpv, which(APCpv == 0), 10^(-43)),
         BCELLpv = replace(BCELLpv, which(BCELLpv == 0), 10^(-41)),
         CD4pv   = replace(CD4pv, which(CD4pv == 0), 10^(-28)), 
         CD8pv   = replace(CD8pv, which(CD8pv == 0), 10^(-28)), 
         TREGpv  = replace(TREGpv, which(TREGpv == 0), 10^(-35)))
```

## VI. SVM

We ran the SVM analysis separately for the specified networks. The SVMs were trained to distinguish genes in the gene list from randomly chosen genes from outside the list. We use the function generate.triage.models() to accomplish this, which uses the ``svm`` function in the package ``e1071``. The features used by the SVM are the edge weights between all genes and the genes in the GWAS gene list. For each of the 100 SVM models, we used the GWAS genes as the true positives, while the true negatives were selected at random from outside of that gene set. Each true negative set was selected to have the same number of genes as were in the true positive set. 

A. Train SVM using the GWAS genes and the specified functional network
```{r train_SVM}
#set paramaters
n.SVM <- 100
n.cores = detectCores()-1 #The number of cores to use for parallel processing

# 1. Intestine
generate.triage.models(path = results.int.dir, 
                       project.name = "IBDint", 
                       trait.genes = IBD.gconvert$target,
                       fgn = intfgn, 
                       n.trials = n.SVM, 
                       cluster.modules = FALSE, 
                       use.SVD = FALSE, 
                       verbose = TRUE, 
                       n.cores = n.cores)

# 2. Hemolymphoid
generate.triage.models(path = results.hemo.dir, 
                       project.name = "IBDhemo", 
                       trait.genes = IBD.gconvert$target,
                       fgn = hemofgn, 
                       n.trials = n.SVM, 
                       cluster.modules = FALSE, 
                       use.SVD = FALSE, 
                       verbose = TRUE, 
                       n.cores = n.cores)
```

B. ROC curves 
Following training of the SVM models, we evaluted them by generating ROC curves to test how well the models separate genes annotated to the network from genes in the rest of the genome. To do this, use the svm.ROC function, which plots the false positive rate against the true positive rate of the SVM model across the full range of prediction values. An area under the ROC curve (AUC) indicates how well the model does overall (AUC 0.5 means model performs at random chance, AUC 1 means model has perfect classification)
```{r ROC_curve}
#1. Intestine
svm.ROC(results.int.dir, n.cores = n.cores, plot.results = TRUE)

#2. Hemolymphoid
svm.ROC(results.hemo.dir, n.cores = n.cores, plot.results = TRUE)
```

C. Apply the trained models to genes
After training the SVM models, we use them to classify each gene, where each gene recieves a score from each SVM indicating whether the model identifies it as part of the [network] gene list (a positive score) or not part of the gene list (negative score). The score.candidates function writes out all of the values to two csv tables (Candidate.Gene.SVM.Scores.csv and Candidate.Gene.FP.Rates.csv). [Note: The function also plots boxplots of the distributions of the SVM scores and the false positive (FP) rates for each gene in two jpgs (Candidate.Gene.SVM.Scores.jpg, and Candidate.Gene.FP.Rates.jpg). Plots are ordered by mean value. however, this iteration doesn't create them??]
The genes that are on the left are classified confidently by the SVM as being related to the [network] gene list. The distributions of their SVM scores do not cross 0. The genes on the right hand side are classified confidently by the SVM as not being related to the [network] gene list. The genes in between are less confidently classified across the SVM trials. 
```{r score_candidates}
#1. Intestine
score.candidates(results.int.dir, candidate.genes = DEG.chr$EntrezID)

#2. Hemolymphoid
score.candidates(results.hemo.dir, candidate.genes = DEG.chr$EntrezID)
```

## VII.   Integrate Gene Information with SVM Output

We integrated the SVM scores and FP Rates with the original gene information (DEG.all). The function merge.gene.svm.fp takes the original gene table (DEG.all) and adds the columns for the mean SVM score and mean FP rate to the genes. It writes out a table for each module with the information for each gene, including the original information from the gene table (entrez ID, gene name, expression p-values, position data, etc.), SVM score, and FP rate (Candidate.Gene.Results.rds). 
```{r merge_info}
#gene.column.name is the column name from the gene.info.table with the entrez IDs

#1. Intestine
int.final.table <- merge.gene.svm.fp(results.int.dir, gene.info.table = DEG.chr, gene.column.name = "EntrezID")

#2. Hemolymphoid
hemo.final.table <- merge.gene.svm.fp(results.hemo.dir, gene.info.table = DEG.chr, gene.column.name = "EntrezID")
```

## VIII.  Gene Scores

Each gene is scored based on the integration of SVM false positive (FP) rates, GWAS p-values, and potentially other metrics given the dataset (e.g., expression data). Given two variables (i.e., -log p-value and -log SVM FP rate), the score is based on the number of genes in the area covered by its x,y position. An individual gene with a lot of genes covered in their area will be ranked higher than a gene with fewer. Given only positional information and SVM output, genes can be ranked on their FP rates and mapped by their position (and significant GWAS genes can also be designated from the rest). 

A. Log transformation
```{r gene_value_transformation}
#Here, there are five p-values corresponding to five cell types for this DEG dataset. Each will be log transformed and scaled to 1. 

#1. Intestine
int.final.table %<>%
  mutate(APC.log_p    = -log10(APCpv), 
         BCELL.log_p  = -log10(BCELLpv),
         CD4.log_p    = -log10(CD4pv), 
         CD8.log_p    = -log10(CD8pv), 
         TREG.log_p   = -log10(TREGpv),
         #FP rates
         log_fp = -log10(mean.fp.rate))

#2. Hemolymphoid 
hemo.final.table %<>%
  mutate(APC.log_p    = -log10(APCpv), 
         BCELL.log_p  = -log10(BCELLpv),
         CD4.log_p    = -log10(CD4pv), 
         CD8.log_p    = -log10(CD8pv), 
         TREG.log_p   = -log10(TREGpv),
         #FP rates
         log_fp = -log10(mean.fp.rate))
```

B. Score calculation
Final DEG/SVM prioritization gene score is calculated as follows: for every gene in the -log p-value x -log SVM FP rate plot, how many genes are in the are covered by its position. Individual genes with more (other) genes in their positional box will be ranked higher as they dominate more of the genes contained in the plot. This calculation maximizes both measures for a single gene. (note: this score incorporates non-significant values in the chromosome, but the plots will be significant genes only)
```{r score}
#1. Intestine
int.final.table %<>% 
  mutate(total.score = )


#2. Hemolymphoid


for(i in 1:length(final.tableTRANS$entrezgene)){
  final.tableTRANS$BetterThan[[i]] <- length(intersect(final.tableTRANS$entrezgene[final.tableTRANS$Mean.FP.Rate < final.tableTRANS$Mean.FP.Rate[[i]]],
               final.tableTRANS$entrezgene[final.tableTRANS$APCpv < final.tableTRANS$APCpv[[i]]]))
}
```




## IX.   Plot value preparation
```{r}
#1. Intestine
int.final.table %<>%
  mutate(APC.log_p    = -log10(APCpv), 
         BCELL.log_p  = -log10(BCELLpv),
         CD4.log_p    = -log10(CD4pv), 
         CD8.log_p    = -log10(CD8pv), 
         TREG.log_p   = -log10(TREGpv),
         #scaled
         APC.log_p1   = APC.log_p/max(APC.log_p),
         BCELL.log_p1 = BCELL.log_p/max(BCELL.log_p),
         CD4.log_p1   = CD4.log_p/max(CD4.log_p),
         CD8.log_p1   = CD8.log_p/max(CD8.log_p),
         TREG.log_p1  = TREG.log_p/max(TREG.log_p),
         #FP rates
         log_fp = -log10(mean.fp.rate),
         log_fp1 = log_fp/max(log_fp)) 

#2. Hemolymphoid 
hemo.final.table %<>%
  mutate(APC.log_p    = -log10(APCpv), 
         BCELL.log_p  = -log10(BCELLpv),
         CD4.log_p    = -log10(CD4pv), 
         CD8.log_p    = -log10(CD8pv), 
         TREG.log_p   = -log10(TREGpv),
         #scaled
         APC.log_p1   = APC.log_p/max(APC.log_p),
         BCELL.log_p1 = BCELL.log_p/max(BCELL.log_p),
         CD4.log_p1   = CD4.log_p/max(CD4.log_p),
         CD8.log_p1   = CD8.log_p/max(CD8.log_p),
         TREG.log_p1  = TREG.log_p/max(TREG.log_p),
         #FP rates
         log_fp = -log10(mean.fp.rate),
         log_fp1 = log_fp/max(log_fp)) 
```



## X.    Plotting Integrated Ranking















##create subset lists from final.table that represent only significant p values for that cell
```{r subset SIG p values from final.table}
#CELL 1
final.tableSIG <- 
  final.table %>%
  filter(APCpv < 0.05) #take only significant p values
  
#CELL 2
final.table2SIG <- 
  final.table2 %>%
  filter(BCELLpv < 0.05)

#CELL 3
final.table3SIG <- 
  final.table3 %>%
  filter(CD4pv < 0.05)

#CELL 4
final.table4SIG <- 
  final.table4 %>%
  filter(CD8pv < 0.05)

#CELL 5
final.table5SIG <- 
  final.table5 %>%
  filter(TREGpv < 0.05)

#note - numbers should more or less match when SWITCH happened, to filter by significant p value before classifying. not all genes can be classified though, so the final.tables will have slightly less
```





## V. NEW RANKING SYSTEM and PLOT


## CELL 1

instead of having the final ranking be the SVM FP rate PLUS the p-value, we will use the following metric: 
for every gene in the -log p-value x -log SVM FP rate plot, how many genes are in the area covered by its position. individual genes with more (other) genes in their area box will be ranked higher as they dominate more of the genes contained in the plot

```{r rank cell 1}
##CREATE NEW TABLES FIRST - containing -log fp, -log pvalue, symbol, and number dominating
##this chunk is also overlapping with the V. PLOT chunks ## DO NOT RUN THOSE RIGHT NOW

# note- FINAL.TABLE is all the genes without duplicates from chr 1 and 2, the FINAL.TABLESIG are just the genes FROM THAT CELL TYPE that have significant p values
# plots will have just sig p values, but the new ranking will take into consideration all genes 
# FINAL.TABLETRANS is same as final table, but -log10 and scaled, to be able to find the BETTER THAN

#CELL 1
#going to add on the value to final.table (NOT sig table) because want to have all values there

#transform -log10 and scale ALL FPs
final.tableTRANS <- final.table #putting these somewhere else just to be able to make calculations for Better Than (and the plot using just sig, so that uses a different table)
final.tableTRANS$Mean.FP.Rate <- -log10(as.numeric(final.tableTRANS[,"Mean.FP.Rate"]))
final.tableTRANS$Mean.FP.Rate <- final.tableTRANS$Mean.FP.Rate/max(final.tableTRANS$Mean.FP.Rate)
#transform -log10 and scale ALL P VALUES
final.tableTRANS$APCpv <- as.numeric(final.tableTRANS[,"APCpv"])
final.tableTRANS$APCpv[final.tableTRANS[["APCpv"]] == 0] <- 10^(-43) #change zeros - these values were actually found in the next chunk using findingmindegpv
final.tableTRANS$APCpv <- -log10(final.tableTRANS$APCpv) #-log10
final.tableTRANS$APCpv <- final.tableTRANS$APCpv/max(final.tableTRANS$APCpv) #scale

#rank
for(i in 1:length(final.tableTRANS$entrezgene)){
  final.tableTRANS$BetterThan[[i]] <- length(intersect(final.tableTRANS$entrezgene[final.tableTRANS$Mean.FP.Rate < final.tableTRANS$Mean.FP.Rate[[i]]],
               final.tableTRANS$entrezgene[final.tableTRANS$APCpv < final.tableTRANS$APCpv[[i]]]))
}
  #final.tableTRANS$entrezgene[final.tableTRANS$Mean.FP.Rate < final.tableTRANS$Mean.FP.Rate[[1]]] - all genes that gene i is better than for FP
  #final.tableTRANS$entrezgene[final.tableTRANS$APCpv < final.tableTRANS$APCpv[[1]]] - all genes that gene i is better than for p value
  
```


```{r table of -log10 mean FPRs SUPPLEMENTAL}
###SUP TABLE

#transform -log10 and scale ALL FPs
final.tableSUP <- final.table 
final.tableSUP$log10.Mean.FP.Rate <- -log10(as.numeric(final.tableSUP[,"Mean.FP.Rate"]))
final.tableSUP$Scaled.Mean.FP.Rate <- final.tableSUP$log10.Mean.FP.Rate/max(final.tableSUP$log10.Mean.FP.Rate)

write.csv(final.tableSUP, "INT_allFPRstable.csv")
```





```{r plot}
#do line by line and do the other chunk part first to find the value

DEGpvSIG <- as.numeric(final.tableSIG[,"APCpv"])
FindingMinDEGpv <-  DEGpvSIG[DEGpvSIG!=0] #to find min that isn't a zero use min(FindingMinDEGpv)
DEGpvSIG[DEGpvSIG==0] <- 10^(-43)

DEGpvlog10SIG <- -log10(DEGpvSIG)
max.DEGpvlog10 <- max(DEGpvlog10SIG)
DEGpvlog10SIG <- DEGpvlog10SIG/max.DEGpvlog10 #scale

fplog10SIG <- -log10(as.numeric(final.tableSIG[,"Mean.FP.Rate"]))
max.fplog10 <- max(fplog10SIG)
fplog10SIG <- fplog10SIG/max.fplog10

#put them all together
DEGfptable <- data.frame(final.tableSIG[, "Symbol"], DEGpvlog10SIG, fplog10SIG)
colnames(DEGfptable) <- c("Symbol", "DEGpvlog10", "fplog10")


###add rank to table, but have to create a different one because the plot relies on the original, this is to be able to use top 10 and label
# final.tableTRANS[which.max(final.tableTRANS$Mean.FP.Rate),]le - not using
DEGfptablewBT <- DEGfptable
DEGfptablewBT$BetterThan <- final.tableTRANS$BetterThan[match(DEGfptablewBT$Symbol, final.tableTRANS$Symbol)]
#table1$val2 <- table2$val2[match(table1$pid, table2$pid)] #this was the example to be able to do this

#use this to find top 10 ranked by better than in the list for this cell
top10_1 <- top_n(DEGfptablewBT, 10, DEGfptablewBT$BetterThan)
#will need to take out any intersection with pref below


# LABELS AND POINTS NEEDED FOR PLOT  
pref <- psel(DEGfptable, high(DEGpvlog10SIG) * high(fplog10SIG))
subsetlog <- DEGfptable$Symbol %in% as.character(pref[[1]]) #need this to subset labels on pareto front
#need to take out any intersection with pref from subset top 10 = top10 names minus pref
top10naMinuspref <- top10_1[[1]][!(top10_1$Symbol %in% as.character(pref[[1]]))]
#df1[!(df1$name %in% df2$name),] #use this as the example to take out rows based on intersection with another data frame
#full logical array taking out labels for the top 10 minus pref - will use this in ggplot for labels
subsettop10_1 <- DEGfptable$Symbol %in% as.character(top10naMinuspref) #need this to subset labels for top 10 ranked

# PLOT 
ggplot(DEGfptable, aes(x = DEGpvlog10, y = fplog10, label = Symbol)) + 
  geom_point(shape = 21, color = "gray20") + #all other gene points
  geom_step(data = pref, direction = "vh", color = "lightblue", size = 1.5) +  # pareto line
  geom_point(data = pref, shape = 20, size = 10, color = "orange") + #pareto line points 
  geom_point(data = top10_1, shape = 20, size = 5.5, color = "tomato3") + #top 10 ranked (better than) points
  geom_text(aes(x = DEGpvlog10, y = fplog10, label= Symbol), subset(DEGfptable, subset = subsetlog), hjust = -0.2, vjust = -0.5, angle = 15, size = 5) + #pareto labels
  geom_text(aes(x = DEGpvlog10, y = fplog10, label= Symbol), subset(DEGfptable, subset = subsettop10_1), hjust = -0.2, vjust = -0.5, angle = 15, position = "jitter", size = 5) + #top 10 labels
  ggtitle("APC") + 
  labs(y="-log10 SVM FP Rate", x = "-log10 Differential Gene Expression p value") + 
  coord_equal() +
  theme(axis.title = element_text(size=30), axis.text = element_text(size = 15)) +
  xlim(0, 1.05) + 
  ylim(0, 1.05) #+ geom_line(y = 0.2, colour = "darkgray", linetype = 2)


#ggsave("CELL1_APC.svg", height = 10, width = 10, units = "in")
#ggsave("CELL1_APC.pdf")


```



## CELL 2

instead of having the final ranking be the SVM FP rate PLUS the p-value, we will use the following metric: 
for every gene in the -log p-value x -log SVM FP rate plot, how many genes are in the area covered by its position. individual genes with more (other) genes in their area box will be ranked higher as they dominate more of the genes contained in the plot
```{r rank cell 2}
##CREATE NEW TABLES FIRST - containing -log fp, -log pvalue, symbol, and number dominating
##this chunk is also overlapping with the V. PLOT chunks ## DO NOT RUN THOSE RIGHT NOW AS THEY ARE 

# note- FINAL.TABLE is all the genes without duplicates from chr 1 and 2, the FINAL.TABLESIG are just the genes FROM THAT CELL TYPE that have significant p values
# plots will have just sig p values, but the new ranking will take into consideration all genes
# FINAL.TABLETRANS is same as final table, but -log10 and scaled, to be able to find the BETTER THAN

#CELL 2

#going to add on the value to final.table (NOT sig table) because want to have all values there

#transform -log10 and scale ALL FPs
final.table2TRANS <- final.table2
final.table2TRANS$Mean.FP.Rate <- -log10(as.numeric(final.table2TRANS[,"Mean.FP.Rate"]))
final.table2TRANS$Mean.FP.Rate <- final.table2TRANS$Mean.FP.Rate/max(final.table2TRANS$Mean.FP.Rate)
#transform -log10 and scale ALL P VALUES
final.table2TRANS$BCELLpv <- as.numeric(final.table2TRANS[,"BCELLpv"])
final.table2TRANS$BCELLpv[final.table2TRANS[["BCELLpv"]] == 0] <- 10^(-41) #change zeros
final.table2TRANS$BCELLpv <- -log10(final.table2TRANS$BCELLpv) #-log10
final.table2TRANS$BCELLpv <- final.table2TRANS$BCELLpv/max(final.table2TRANS$BCELLpv) #scale

for(i in 1:length(final.table2TRANS$entrezgene)){
  final.table2TRANS$BetterThan[[i]] <- length(intersect(final.table2TRANS$entrezgene[final.table2TRANS$Mean.FP.Rate < final.table2TRANS$Mean.FP.Rate[[i]]],
               final.table2TRANS$entrezgene[final.table2TRANS$BCELLpv < final.table2TRANS$BCELLpv[[i]]]))
}
  #final.tableTRANS$entrezgene[final.tableTRANS$Mean.FP.Rate < final.tableTRANS$Mean.FP.Rate[[1]]] - all genes that gene i is better than for FP
  #final.tableTRANS$entrezgene[final.tableTRANS$APCpv < final.tableTRANS$APCpv[[1]]] - all genes that gene i is better than for p value
  
```


```{r plot cell 2}
DEGpv2SIG <- as.numeric(final.table2SIG[,"BCELLpv"])
FindingMinDEGpv <-  DEGpv2SIG[DEGpv2SIG!=0] #to find min that isn't a zero use min(FindingMinDEGpv)
DEGpv2SIG[DEGpv2SIG==0] <- 10^(-41)

DEGpv2log10SIG <- -log10(DEGpv2SIG)
max.DEGpv2log10 <- max(DEGpv2log10SIG)
DEGpv2log10SIG <- DEGpv2log10SIG/max.DEGpv2log10 #scale

fp2log10SIG <- -log10(as.numeric(final.table2SIG[,"Mean.FP.Rate"]))
max.fp2log10 <- max(fp2log10SIG)
fp2log10SIG <- fp2log10SIG/max.fp2log10

#put them all together
DEGfptable2 <- data.frame(final.table2SIG[, "Symbol"], DEGpv2log10SIG, fp2log10SIG)
colnames(DEGfptable2) <- c("Symbol", "DEGpv2log10", "fp2log10")

###add rank to table, but have to create a different one because the plot relies on the original, this is to be able to use top 10 and label
# final.tableTRANS[which.max(final.tableTRANS$Mean.FP.Rate),]le
#final.table$BetterThan <- final.tableTRANS$BetterThan
DEGfptable2wBT <- DEGfptable2
DEGfptable2wBT$BetterThan <- final.table2TRANS$BetterThan[match(DEGfptable2wBT$Symbol, final.table2TRANS$Symbol)]
#table1$val2 <- table2$val2[match(table1$pid, table2$pid)] #this was the example to be able to do this

#use this to find top 10 ranked by better than in the list for the 
top10_2 <- top_n(DEGfptable2wBT, 10, DEGfptable2wBT$BetterThan)
#will need to take out any intersection with pref below


# LABELS AND POINTS NEEDED FOR PLOT  
pref2 <- psel(DEGfptable2, high(DEGpv2log10SIG) * high(fp2log10SIG))
subsetlog2 <- DEGfptable2$Symbol %in% as.character(pref2[[1]]) #need this to subset labels on pareto front
#need to take out any intersection with pref from subset top 10 = top10 names minus pref
top10naMinuspref2 <- top10_2[[1]][!(top10_2$Symbol %in% as.character(pref2[[1]]))]
#df1[!(df1$name %in% df2$name),] #use this as the example to take out rows based on intersection with another data frame
#full logical array taking out labels for the top 10 minus pref - will use this in ggplot for labels
subsettop10_2 <- DEGfptable2$Symbol %in% as.character(top10naMinuspref2) #need this to subset labels for top 10 ranked

# PLOT 
ggplot(DEGfptable2, aes(x = DEGpv2log10, y = fp2log10, label = Symbol)) + 
  geom_point(shape = 21, color = "gray20") + #all other gene points
  geom_step(data = pref2, direction = "vh", color = "lightblue", size = 1.5) +  # pareto line
  geom_point(data = pref2, shape = 20, size = 10, color = "orange") + #pareto line points 
  geom_point(data = top10_2, shape = 20, size = 5.5, color = "tomato3") + #top 10 ranked (better than) points
  geom_text(aes(x = DEGpv2log10, y = fp2log10, label= Symbol), subset(DEGfptable2, subset = subsetlog2), hjust = -0.2, vjust = -0.5, angle = 15, size = 5) + #pareto labels
  geom_text(aes(x = DEGpv2log10, y = fp2log10, label= Symbol), subset(DEGfptable2, subset = subsettop10_2), hjust = -0.2, vjust = -0.5, angle = 15, position = "jitter", size = 5) + #top 10 labels
  ggtitle("B CELL") + 
  labs(y="-log10 SVM FP Rate", x = "-log10 Differential Gene Expression p value") + 
  theme(axis.title = element_text(size=30), axis.text = element_text(size = 15)) +
  xlim(0, 1.05) + 
  ylim(0, 1.05) #+ geom_line(y = 0.2, colour = "darkgray", linetype = 2)


#ggsave("CELL2_BCELL.svg", height = 10, width = 10, units = "in")
# ggsave("CELL2_BCELL.pdf")


```



## CELL 3

instead of having the final ranking be the SVM FP rate PLUS the p-value, we will use the following metric: 
for every gene in the -log p-value x -log SVM FP rate plot, how many genes are in the area covered by its position. individual genes with more (other) genes in their area box will be ranked higher as they dominate more of the genes contained in the plot
```{r rank cell 3}
##CREATE NEW TABLES FIRST - containing -log fp, -log pvalue, symbol, and number dominating
##this chunk is also overlapping with the V. PLOT chunks ## DO NOT RUN THOSE RIGHT NOW AS THEY ARE 

# note- FINAL.TABLE is all the genes without duplicates from chr 1 and 2, the FINAL.TABLESIG are just the genes FROM THAT CELL TYPE that have significant p values
# plots will have just sig p values, but the new ranking will take into consideration all genes
# FINAL.TABLETRANS is same as final table, but -log10 and scaled, to be able to find the BETTER THAN

#CELL 3

#going to add on the value to final.table (NOT sig table) because want to have all values there

#transform -log10 and scale ALL FPs
final.table3TRANS <- final.table3
final.table3TRANS$Mean.FP.Rate <- -log10(as.numeric(final.table3TRANS[,"Mean.FP.Rate"]))
final.table3TRANS$Mean.FP.Rate <- final.table3TRANS$Mean.FP.Rate/max(final.table3TRANS$Mean.FP.Rate)
#transform -log10 and scale ALL P VALUES
final.table3TRANS$CD4pv <- as.numeric(final.table3TRANS[,"CD4pv"])
final.table3TRANS$CD4pv[final.table3TRANS[["CD4pv"]] == 0] <- 10^(-28) #change zeros
final.table3TRANS$CD4pv <- -log10(final.table3TRANS$CD4pv) #-log10
final.table3TRANS$CD4pv <- final.table3TRANS$CD4pv/max(final.table3TRANS$CD4pv) #scale

for(i in 1:length(final.table3TRANS$entrezgene)){
  final.table3TRANS$BetterThan[[i]] <- length(intersect(final.table3TRANS$entrezgene[final.table3TRANS$Mean.FP.Rate < final.table3TRANS$Mean.FP.Rate[[i]]],
               final.table3TRANS$entrezgene[final.table3TRANS$CD4pv < final.table3TRANS$CD4pv[[i]]]))
}
  #final.tableTRANS$entrezgene[final.tableTRANS$Mean.FP.Rate < final.tableTRANS$Mean.FP.Rate[[1]]] - all genes that gene i is better than for FP
  #final.tableTRANS$entrezgene[final.tableTRANS$APCpv < final.tableTRANS$APCpv[[1]]] - all genes that gene i is better than for p value
  
```


```{r plot cell 3}
DEGpv3SIG <- as.numeric(final.table3SIG[,"CD4pv"])
FindingMinDEGpv <-  DEGpv3SIG[DEGpv3SIG!=0] #to find min that isn't a zero use min(FindingMinDEGpv)
DEGpv3SIG[DEGpv3SIG==0] <- 10^(-28)

DEGpv3log10SIG <- -log10(DEGpv3SIG)
max.DEGpv3log10 <- max(DEGpv3log10SIG)
DEGpv3log10SIG <- DEGpv3log10SIG/max.DEGpv3log10 #scale

fp3log10SIG <- -log10(as.numeric(final.table3SIG[,"Mean.FP.Rate"]))
max.fp3log10 <- max(fp3log10SIG)
fp3log10SIG <- fp3log10SIG/max.fp3log10

#put them all together
DEGfptable3 <- data.frame(final.table3SIG[, "Symbol"], DEGpv3log10SIG, fp3log10SIG)
colnames(DEGfptable3) <- c("Symbol", "DEGpv3log10", "fp3log10")

###add rank to table, but have to create a different one because the plot relies on the original, this is to be able to use top 10 and label
# final.tableTRANS[which.max(final.tableTRANS$Mean.FP.Rate),]le
#final.table$BetterThan <- final.tableTRANS$BetterThan
DEGfptable3wBT <- DEGfptable3
DEGfptable3wBT$BetterThan <- final.table3TRANS$BetterThan[match(DEGfptable3wBT$Symbol, final.table3TRANS$Symbol)]
#table1$val2 <- table2$val2[match(table1$pid, table2$pid)] #this was the example to be able to do this

#use this to find top 10 ranked by better than in the list for the 
top10_3 <- top_n(DEGfptable3wBT, 10, DEGfptable3wBT$BetterThan)
#will need to take out any intersection with pref below


# LABELS AND POINTS NEEDED FOR PLOT  
pref3 <- psel(DEGfptable3, high(DEGpv3log10SIG) * high(fp3log10SIG))
subsetlog3 <- DEGfptable3$Symbol %in% as.character(pref3[[1]]) #need this to subset labels on pareto front
#need to take out any intersection with pref from subset top 10 = top10 names minus pref
top10naMinuspref3 <- top10_3[[1]][!(top10_3$Symbol %in% as.character(pref3[[1]]))]
#df1[!(df1$name %in% df2$name),] #use this as the example to take out rows based on intersection with another data frame
#full logical array taking out labels for the top 10 minus pref - will use this in ggplot for labels
subsettop10_3 <- DEGfptable3$Symbol %in% as.character(top10naMinuspref3) #need this to subset labels for top 10 ranked

# PLOT 
ggplot(DEGfptable3, aes(x = DEGpv3log10, y = fp3log10, label = Symbol)) + 
  geom_point(shape = 21, color = "gray20") + #all other gene points
  geom_step(data = pref3, direction = "vh", color = "lightblue", size = 1.5) +  # pareto line
  geom_point(data = pref3, shape = 20, size = 10, color = "orange") + #pareto line points 
  geom_point(data = top10_3, shape = 20, size = 5.5, color = "tomato3") + #top 10 ranked (better than) points
  geom_text(aes(x = DEGpv3log10, y = fp3log10, label= Symbol), subset(DEGfptable3, subset = subsetlog3), hjust = -0.2, vjust = -0.5, angle = 15, size = 5) + #pareto labels
  geom_text(aes(x = DEGpv3log10, y = fp3log10, label= Symbol), subset(DEGfptable3, subset = subsettop10_3), hjust = -0.2, vjust = -0.5, angle = 15, position = "jitter", size = 5) + #top 10 labels
  ggtitle("CD4") + 
  labs(y="-log10 SVM FP Rate", x = "-log10 Differential Gene Expression p value") + 
  theme(axis.title = element_text(size=30), axis.text = element_text(size = 15)) +
  xlim(0, 1.05) + 
  ylim(0, 1.05) #+ geom_line(y = 0.2, colour = "darkgray", linetype = 2)


#ggsave("CELL3_CD4.svg", height = 10, width = 10, units = "in")
#ggsave("CELL3_CD4.pdf")


```



## CELL 4

instead of having the final ranking be the SVM FP rate PLUS the p-value, we will use the following metric: 
for every gene in the -log p-value x -log SVM FP rate plot, how many genes are in the area covered by its position. individual genes with more (other) genes in their area box will be ranked higher as they dominate more of the genes contained in the plot
```{r rank cell 4}
##CREATE NEW TABLES FIRST - containing -log fp, -log pvalue, symbol, and number dominating
##this chunk is also overlapping with the V. PLOT chunks ## DO NOT RUN THOSE RIGHT NOW AS THEY ARE 

# note- FINAL.TABLE is all the genes without duplicates from chr 1 and 2, the FINAL.TABLESIG are just the genes FROM THAT CELL TYPE that have significant p values
# plots will have just sig p values, but the new ranking will take into consideration all genes
# FINAL.TABLETRANS is same as final table, but -log10 and scaled, to be able to find the BETTER THAN

#CELL 4

#going to add on the value to final.table (NOT sig table) because want to have all values there

#transform -log10 and scale ALL FPs
final.table4TRANS <- final.table4
final.table4TRANS$Mean.FP.Rate <- -log10(as.numeric(final.table4TRANS[,"Mean.FP.Rate"]))
final.table4TRANS$Mean.FP.Rate <- final.table4TRANS$Mean.FP.Rate/max(final.table4TRANS$Mean.FP.Rate)
#transform -log10 and scale ALL P VALUES
final.table4TRANS$CD8pv <- as.numeric(final.table4TRANS[,"CD8pv"])
final.table4TRANS$CD8pv[final.table4TRANS[["CD8pv"]] == 0] <- 10^(-28) #change zeros
final.table4TRANS$CD8pv <- -log10(final.table4TRANS$CD8pv) #-log10
final.table4TRANS$CD8pv <- final.table4TRANS$CD8pv/max(final.table4TRANS$CD8pv) #scale

for(i in 1:length(final.table4TRANS$entrezgene)){
  final.table4TRANS$BetterThan[[i]] <- length(intersect(final.table4TRANS$entrezgene[final.table4TRANS$Mean.FP.Rate < final.table4TRANS$Mean.FP.Rate[[i]]],
               final.table4TRANS$entrezgene[final.table4TRANS$CD8pv < final.table4TRANS$CD8pv[[i]]]))
}
  #final.tableTRANS$entrezgene[final.tableTRANS$Mean.FP.Rate < final.tableTRANS$Mean.FP.Rate[[1]]] - all genes that gene i is better than for FP
  #final.tableTRANS$entrezgene[final.tableTRANS$APCpv < final.tableTRANS$APCpv[[1]]] - all genes that gene i is better than for p value
  
```


```{r plot cell 4}
DEGpv4SIG <- as.numeric(final.table4SIG[,"CD8pv"])
FindingMinDEGpv <-  DEGpv4SIG[DEGpv4SIG!=0] #to find min that isn't a zero use min(FindingMinDEGpv)
DEGpv4SIG[DEGpv4SIG==0] <- 10^(-28)

DEGpv4log10SIG <- -log10(DEGpv4SIG)
max.DEGpv4log10 <- max(DEGpv4log10SIG)
DEGpv4log10SIG <- DEGpv4log10SIG/max.DEGpv4log10 #scale

fp4log10SIG <- -log10(as.numeric(final.table4SIG[,"Mean.FP.Rate"]))
max.fp4log10 <- max(fp4log10SIG)
fp4log10SIG <- fp4log10SIG/max.fp4log10

#put them all together
DEGfptable4 <- data.frame(final.table4SIG[, "Symbol"], DEGpv4log10SIG, fp4log10SIG)
colnames(DEGfptable4) <- c("Symbol", "DEGpv4log10", "fp4log10")

###add rank to table, but have to create a different one because the plot relies on the original, this is to be able to use top 10 and label
# final.tableTRANS[which.max(final.tableTRANS$Mean.FP.Rate),]le
#final.table$BetterThan <- final.tableTRANS$BetterThan
DEGfptable4wBT <- DEGfptable4
DEGfptable4wBT$BetterThan <- final.table4TRANS$BetterThan[match(DEGfptable4wBT$Symbol, final.table4TRANS$Symbol)]
#table1$val2 <- table2$val2[match(table1$pid, table2$pid)] #this was the example to be able to do this

#use this to find top 10 ranked by better than in the list for the 
top10_4 <- top_n(DEGfptable4wBT, 10, DEGfptable4wBT$BetterThan)
#will need to take out any intersection with pref below


# LABELS AND POINTS NEEDED FOR PLOT  
pref4 <- psel(DEGfptable4, high(DEGpv4log10SIG) * high(fp4log10SIG))
subsetlog4 <- DEGfptable4$Symbol %in% as.character(pref4[[1]]) #need this to subset labels on pareto front
#need to take out any intersection with pref from subset top 10 = top10 names minus pref
top10naMinuspref4 <- top10_4[[1]][!(top10_4$Symbol %in% as.character(pref4[[1]]))]
#df1[!(df1$name %in% df2$name),] #use this as the example to take out rows based on intersection with another data frame
#full logical array taking out labels for the top 10 minus pref - will use this in ggplot for labels
subsettop10_4 <- DEGfptable4$Symbol %in% as.character(top10naMinuspref4) #need this to subset labels for top 10 ranked

# PLOT 
ggplot(DEGfptable4, aes(x = DEGpv4log10, y = fp4log10, label = Symbol)) + 
  geom_point(shape = 21, color = "gray20") + #all other gene points
  geom_step(data = pref4, direction = "vh", color = "lightblue", size = 1.5) +  # pareto line
  geom_point(data = pref4, shape = 20, size = 10, color = "orange") + #pareto line points 
  geom_point(data = top10_4, shape = 20, size = 5.5, color = "tomato3") + #top 10 ranked (better than) points
  geom_text(aes(x = DEGpv4log10, y = fp4log10, label= Symbol), subset(DEGfptable4, subset = subsetlog4), hjust = -0.2, vjust = -0.5, angle = 15, size = 5) + #pareto labels
  geom_text(aes(x = DEGpv4log10, y = fp4log10, label= Symbol), subset(DEGfptable4, subset = subsettop10_4), hjust = -0.2, vjust = -0.5, angle = 15, position = "jitter", size = 5) + #top 10 labels
  ggtitle("CD8") + 
  labs(y="-log10 SVM FP Rate", x = "-log10 Differential Gene Expression p value") + 
  theme(axis.title = element_text(size=30), axis.text = element_text(size = 15)) +
  xlim(0, 1.05) + 
  ylim(0, 1.05) #+ geom_line(y = 0.2, colour = "darkgray", linetype = 2)


#ggsave("CELL4_CD8.svg", height = 10, width = 10, units = "in")
#ggsave("CELL4_CD8.pdf")


```



## CELL 5

instead of having the final ranking be the SVM FP rate PLUS the p-value, we will use the following metric: 
for every gene in the -log p-value x -log SVM FP rate plot, how many genes are in the area covered by its position. individual genes with more (other) genes in their area box will be ranked higher as they dominate more of the genes contained in the plot
```{r rank cell 5}
##CREATE NEW TABLES FIRST - containing -log fp, -log pvalue, symbol, and number dominating
##this chunk is also overlapping with the V. PLOT chunks ## DO NOT RUN THOSE RIGHT NOW AS THEY ARE 

# note- FINAL.TABLE is all the genes without duplicates from chr 1 and 2, the FINAL.TABLESIG are just the genes FROM THAT CELL TYPE that have significant p values
# plots will have just sig p values, but the new ranking will take into consideration all genes
# FINAL.TABLETRANS is same as final table, but -log10 and scaled, to be able to find the BETTER THAN

#CELL 5

#going to add on the value to final.table (NOT sig table) because want to have all values there

#transform -log10 and scale ALL FPs
final.table5TRANS <- final.table5
final.table5TRANS$Mean.FP.Rate <- -log10(as.numeric(final.table5TRANS[,"Mean.FP.Rate"]))
final.table5TRANS$Mean.FP.Rate <- final.table5TRANS$Mean.FP.Rate/max(final.table5TRANS$Mean.FP.Rate)
#transform -log10 and scale ALL P VALUES
final.table5TRANS$TREGpv <- as.numeric(final.table5TRANS[,"TREGpv"])
final.table5TRANS$TREGpv[final.table5TRANS[["TREGpv"]] == 0] <- 10^(-35) #change zeros
final.table5TRANS$TREGpv <- -log10(final.table5TRANS$TREGpv) #-log10
final.table5TRANS$TREGpv <- final.table5TRANS$TREGpv/max(final.table5TRANS$TREGpv) #scale

for(i in 1:length(final.table5TRANS$entrezgene)){
  final.table5TRANS$BetterThan[[i]] <- length(intersect(final.table5TRANS$entrezgene[final.table5TRANS$Mean.FP.Rate < final.table5TRANS$Mean.FP.Rate[[i]]],
               final.table5TRANS$entrezgene[final.table5TRANS$TREGpv < final.table5TRANS$TREGpv[[i]]]))
}
  #final.tableTRANS$entrezgene[final.tableTRANS$Mean.FP.Rate < final.tableTRANS$Mean.FP.Rate[[1]]] - all genes that gene i is better than for FP
  #final.tableTRANS$entrezgene[final.tableTRANS$APCpv < final.tableTRANS$APCpv[[1]]] - all genes that gene i is better than for p value
  
```


```{r plot cell 5}
DEGpv5SIG <- as.numeric(final.table5SIG[,"TREGpv"])
FindingMinDEGpv <-  DEGpv5SIG[DEGpv5SIG!=0] #to find min that isn't a zero use min(FindingMinDEGpv)
DEGpv5SIG[DEGpv5SIG==0] <- 10^(-35)

DEGpv5log10SIG <- -log10(DEGpv5SIG)
max.DEGpv5log10 <- max(DEGpv5log10SIG)
DEGpv5log10SIG <- DEGpv5log10SIG/max.DEGpv5log10 #scale

fp5log10SIG <- -log10(as.numeric(final.table5SIG[,"Mean.FP.Rate"]))
max.fp5log10 <- max(fp5log10SIG)
fp5log10SIG <- fp5log10SIG/max.fp5log10

#put them all together
DEGfptable5 <- data.frame(final.table5SIG[, "Symbol"], DEGpv5log10SIG, fp5log10SIG)
colnames(DEGfptable5) <- c("Symbol", "DEGpv5log10", "fp5log10")

###add rank to table, but have to create a different one because the plot relies on the original, this is to be able to use top 10 and label
# final.tableTRANS[which.max(final.tableTRANS$Mean.FP.Rate),]le
#final.table$BetterThan <- final.tableTRANS$BetterThan
DEGfptable5wBT <- DEGfptable5
DEGfptable5wBT$BetterThan <- final.table5TRANS$BetterThan[match(DEGfptable5wBT$Symbol, final.table5TRANS$Symbol)]
#table1$val2 <- table2$val2[match(table1$pid, table2$pid)] #this was the example to be able to do this

#use this to find top 10 ranked by better than in the list for the 
top10_5 <- top_n(DEGfptable5wBT, 10, DEGfptable5wBT$BetterThan)
#will need to take out any intersection with pref below


# LABELS AND POINTS NEEDED FOR PLOT  
pref5 <- psel(DEGfptable5, high(DEGpv5log10SIG) * high(fp5log10SIG))
subsetlog5 <- DEGfptable5$Symbol %in% as.character(pref5[[1]]) #need this to subset labels on pareto front
#need to take out any intersection with pref from subset top 10 = top10 names minus pref
top10naMinuspref5 <- top10_5[[1]][!(top10_5$Symbol %in% as.character(pref5[[1]]))]
#df1[!(df1$name %in% df2$name),] #use this as the example to take out rows based on intersection with another data frame
#full logical array taking out labels for the top 10 minus pref - will use this in ggplot for labels
subsettop10_5 <- DEGfptable5$Symbol %in% as.character(top10naMinuspref5) #need this to subset labels for top 10 ranked

# PLOT 
ggplot(DEGfptable5, aes(x = DEGpv5log10, y = fp5log10, label = Symbol)) + 
  geom_point(shape = 21, color = "gray20") + #all other gene points
  geom_step(data = pref5, direction = "vh", color = "lightblue", size = 1.5) +  # pareto line
  geom_point(data = pref5, shape = 20, size = 10, color = "orange") + #pareto line points 
  geom_point(data = top10_5, shape = 20, size = 5.5, color = "tomato3") + #top 10 ranked (better than) points
  geom_text(aes(x = DEGpv5log10, y = fp5log10, label= Symbol), subset(DEGfptable5, subset = subsetlog5), hjust = -0.2, vjust = -0.5, angle = 15, size = 4) + #pareto labels
  geom_text(aes(x = DEGpv5log10, y = fp5log10, label= Symbol), subset(DEGfptable5, subset = subsettop10_5), hjust = -0.2, vjust = -0.5, angle = 15, position = "jitter", size = 5) + #top 10 labels
  ggtitle("T REG") + 
  labs(y="-log10 SVM FP Rate", x = "-log10 Differential Gene Expression p value") + 
  theme(axis.title = element_text(size=30), axis.text = element_text(size = 15)) +
  xlim(0, 1.05) + 
  ylim(0, 1.05) #+ geom_line(y = 0.2, colour = "darkgray", linetype = 2)


#ggsave("CELL5_TREG.svg", height = 10, width = 10, units = "in")
#ggsave("CELL5_TREG.pdf")


```



## All Pref and top 10
this is just for my personal visualization 

```{r allPref and allTop10 tables}
#all genes on pareto fronts from all five cell types
allPref <- bind_rows(pref, pref2, pref3, pref4, pref5)
allPrefnames <- c(as.character(pref[[1]]), as.character(pref2[[1]]), as.character(pref3[[1]]), as.character(pref4[[1]]), as.character(pref5[[1]]))

#were these in the original SVM training?
inTraining <- toupper(allPref[[1]]) %in% as.character(IBDGWASmouseEntrez[["name"]])
#use allPref[[1]][inTraining] to see which were used in training (toupper is for case sensitivity)


## Add BETTER THAN scores to all Pref (just to see)
allPref$Betterthan1 <- final.tableTRANS$BetterThan[match(allPref$Symbol, final.tableTRANS$Symbol)]
allPref$Betterthan2 <- final.table2TRANS$BetterThan[match(allPref$Symbol, final.table2TRANS$Symbol)]
allPref$Betterthan3 <- final.table3TRANS$BetterThan[match(allPref$Symbol, final.table3TRANS$Symbol)]
allPref$Betterthan4 <- final.table4TRANS$BetterThan[match(allPref$Symbol, final.table4TRANS$Symbol)]
allPref$Betterthan5 <- final.table5TRANS$BetterThan[match(allPref$Symbol, final.table5TRANS$Symbol)]

#all top together
allTop10 <- bind_rows(top10_1, top10_2, top10_3, top10_4, top10_5)
allTop10$BetterThan <- NULL #takes out the better than from the original top10s that overlap 
#add better than
allTop10$Betterthan1 <- final.tableTRANS$BetterThan[match(allTop10$Symbol, final.tableTRANS$Symbol)]
allTop10$Betterthan2 <- final.table2TRANS$BetterThan[match(allTop10$Symbol, final.table2TRANS$Symbol)]
allTop10$Betterthan3 <- final.table3TRANS$BetterThan[match(allTop10$Symbol, final.table3TRANS$Symbol)]
allTop10$Betterthan4 <- final.table4TRANS$BetterThan[match(allTop10$Symbol, final.table4TRANS$Symbol)]
allTop10$Betterthan5 <- final.table5TRANS$BetterThan[match(allTop10$Symbol, final.table5TRANS$Symbol)]
#these are inclusive of pareto front genes

#allpref + alltop
ALLprefALLtop <- rbind(allPref, allTop10)

```

``` {r SUPPLEMENTAL}

#for just supplemental
ALLprefALLtopSUP <- ALLprefALLtop


  #### EXPORT FOR SUPPLEMENTAL
for (i in 1:nrow(ALLprefALLtopSUP)) {
  #if there is a number and not an NA in the first column row i
  if (!is.na(ALLprefALLtopSUP$DEGpvlog10[i]))   {
    #then put the number from better than into the new bt1 column
    ALLprefALLtopSUP$BT1[i] <- ALLprefALLtopSUP$Betterthan1[i]
  } else {
    ALLprefALLtopSUP$BT1[i] <- NA
  }
}
for (i in 1:nrow(ALLprefALLtopSUP)) {
  #if there is a number and not an NA in the first column row i
  if (!is.na(ALLprefALLtopSUP$DEGpv2log10[i]))   {
    #then put the number from better than into the new bt1 column
    ALLprefALLtopSUP$BT2[i] <- ALLprefALLtopSUP$Betterthan2[i]
  } else {
    ALLprefALLtopSUP$BT2[i] <- NA
  }
}
for (i in 1:nrow(ALLprefALLtopSUP)) {
  #if there is a number and not an NA in the first column row i
  if (!is.na(ALLprefALLtopSUP$DEGpv3log10[i]))   {
    #then put the number from better than into the new bt1 column
    ALLprefALLtopSUP$BT3[i] <- ALLprefALLtopSUP$Betterthan3[i]
  } else {
    ALLprefALLtopSUP$BT3[i] <- NA
  }
}
for (i in 1:nrow(ALLprefALLtopSUP)) {
  #if there is a number and not an NA in the first column row i
  if (!is.na(ALLprefALLtopSUP$DEGpv4log10[i]))   {
    #then put the number from better than into the new bt1 column
    ALLprefALLtopSUP$BT4[i] <- ALLprefALLtopSUP$Betterthan4[i]
  } else {
    ALLprefALLtopSUP$BT4[i] <- NA
  }
}
for (i in 1:nrow(ALLprefALLtopSUP)) {
  #if there is a number and not an NA in the first column row i
  if (!is.na(ALLprefALLtopSUP$DEGpv5log10[i]))   {
    #then put the number from better than into the new bt1 column
    ALLprefALLtopSUP$BT5[i] <- ALLprefALLtopSUP$Betterthan5[i]
  } else {
    ALLprefALLtopSUP$BT5[i] <- NA
  }
}
  
#take out unecessary columns 
ALLprefALLtopSUP <- ALLprefALLtopSUP[ , c(1, 17:21)]

ALLprefALLtopSUP %<>%
  group_by(Symbol) %>%
  summarise_all(mean, na.rm = TRUE)

write.csv(ALLprefALLtopSUP, "IntALLprefALLtop.csv")
#see below for the same table though

####
#making allPref that has no duplicates 
##not done yet
# LABELS AND POINTS NEEDED FOR PLOT  
# pref5 <- psel(DEGfptable5, high(DEGpv5log10SIG) * high(fp5log10SIG))
# subsetlog5 <- DEGfptable5$Symbol %in% as.character(pref5[[1]]) #need this to subset labels on pareto front
# #need to take out any intersection with pref from subset top 10 = top10 names minus pref
# top10naMinuspref5 <- top10_5[[1]][!(top10_5$Symbol %in% as.character(pref5[[1]]))]
# #df1[!(df1$name %in% df2$name),] #use this as the example to take out rows based on intersection with another data frame
# #full logical array taking out labels for the top 10 minus pref - will use this in ggplot for labels
# subsettop10_5 <- DEGfptable5$Symbol %in% as.character(top10naMinuspref5) #need this to subset labels for top 10 ranked

```



##VII. heatmap tables to use for fold change heatmap with final.score for allpref


```{r ggplot for heatmap chr1 }
#redo the heatmaptables first using pareto AND top genes
#chr. 1


heatmaptableAPC <- 
  final.tableTRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref[[1]]), as.character(top10_1[[1]])))
  

heatmaptableBCELL <- 
  final.table2TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref2[[1]]), as.character(top10_2[[1]])))

heatmaptableCD4 <-
  final.table3TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref3[[1]]), as.character(top10_3[[1]])))

heatmaptableCD8 <- 
  final.table4TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref4[[1]]), as.character(top10_4[[1]])))

heatmaptableTREG <- 
  final.table5TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref5[[1]]), as.character(top10_5[[1]])))

#get FC for each cell type from all the tables
heatmaptable <- 
  rbind((cbind(heatmaptableAPC$Symbol,heatmaptableAPC$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableAPC$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableAPC$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableAPC$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableAPC$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableAPC$BetterThan)), 
        (cbind(heatmaptableBCELL$Symbol, heatmaptableBCELL$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableBCELL$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableBCELL$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableBCELL$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableBCELL$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableBCELL$BetterThan)), 
        (cbind(heatmaptableCD4$Symbol, heatmaptableCD4$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableCD4$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableCD4$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableCD4$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableCD4$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableCD4$BetterThan)), 
        (cbind(heatmaptableCD8$Symbol, heatmaptableCD8$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableCD8$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableCD8$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableCD8$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableCD8$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableCD8$BetterThan)), 
        (cbind(heatmaptableTREG$Symbol, heatmaptableTREG$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableTREG$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableTREG$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableTREG$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableTREG$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableTREG$BetterThan)))



#change column names to be able to work with
heatmaptable <- data.frame(heatmaptable, stringsAsFactors = FALSE) #have to do this so the levels don't cary over
colnames(heatmaptable) <- c("Symbol", "FCapc", "FCbcell", "FCcd4", "FCcd8", "FCtreg", "BetterThan")

#take out duplicates and just use top ranked line
heatmaptable <- 
  heatmaptable %>%
  group_by(Symbol) %>%
  top_n(1, BetterThan) %>%
  distinct(Symbol, .keep_all= TRUE) %>%
  ungroup()
#have to turn this into numeric first to be able to order it
heatmaptable$BetterThan <- as.numeric(heatmaptable$BetterThan)
#order by better than
heatmaptableordered <- as.data.frame(heatmaptable[order(as.numeric(as.character(heatmaptable$BetterThan)), decreasing = FALSE),][ , 1:6])

#have to reshape table
heatmaptableordered$FCapc <- as.numeric(as.character((heatmaptableordered$FCapc)))
heatmaptableordered$FCbcell <- as.numeric(as.character((heatmaptableordered$FCbcell)))
heatmaptableordered$FCcd4 <- as.numeric(as.character((heatmaptableordered$FCcd4)))
heatmaptableordered$FCcd8 <- as.numeric(as.character((heatmaptableordered$FCcd8)))
heatmaptableordered$FCtreg <- as.numeric(as.character((heatmaptableordered$FCtreg)))

#heatmap

#get range to be able to find the limits for ggplot (then can use this to do breaks)
allFCch1 <- c(heatmaptableordered$FCapc, heatmaptableordered$FCbcell, heatmaptableordered$FCcd4, heatmaptableordered$FCcd8, heatmaptableordered$FCtreg)
RANGEallFCch1 <- range(allFCch1) #to find RANGE
#range = -267, 4
#SECONDminallFCch1 <- min(allFCch1[allFCch1!=min(range(allFCch1))])
#here it is

#find where to put the breaks - this is just to visualize and map what number to put for which break value
BreaksChr1Numbers <- as.data.frame(seq(4, -10)) # INSTEAD USE QUANT below - and use the range for the min, and the quant for the max below the extreme values
BreaksChr1Numbers$values <- seq(-100, 0, length.out = 15)

# NEW IDEA - use 95% and 5%
QUANTallFCch1 <- quantile(allFCch1, c(.05, .95))
# 5% -9.354619 and 95% 2.311628 



#pick out the gene/cell combo that have sig p values 
heatmaptableWpv <- heatmaptableordered
heatmaptableWpv$APCpv <- final.table$APCpv[match(heatmaptableWpv$Symbol, final.table$Symbol)]
heatmaptableWpv$BCELLpv <- final.table$BCELLpv[match(heatmaptableWpv$Symbol, final.table$Symbol)]
heatmaptableWpv$CD4pv <- final.table$CD4pv[match(heatmaptableWpv$Symbol, final.table$Symbol)]
heatmaptableWpv$CD8pv <- final.table$CD8pv[match(heatmaptableWpv$Symbol, final.table$Symbol)]
heatmaptableWpv$TREGpv <- final.table$TREGpv[match(heatmaptableWpv$Symbol, final.table$Symbol)]

#turn insignificant p values to zero in the fold change
heatmaptableWpv$FCapc[heatmaptableWpv$APCpv > 0.05] <- 0
heatmaptableWpv$FCbcell[heatmaptableWpv$BCELLpv > 0.05] <- 0
heatmaptableWpv$FCcd4[heatmaptableWpv$CD4pv > 0.05] <- 0
heatmaptableWpv$FCcd8[heatmaptableWpv$CD8pv > 0.05] <- 0
heatmaptableWpv$FCtreg[heatmaptableWpv$TREGpv > 0.05] <- 0

# #dataframe with just fc values filtered by if the p value was significant
# heatmaptableWpv[,2:6] %>% filter(heatmaptableWpv$APCpv < 0.05)
# range(mutate_all(heatmaptable[,2:6], function(x) as.numeric(as.character(x))))

#melt new heatmaptable with NAs
heatmaptableWOpv <- as.data.frame(heatmaptableWpv[, 1:6])
colnames(heatmaptableWOpv) <- c("Symbol", "APC", "BCell", "CD4", "CD8", "TReg")
heatmaptableWOpv.m <- melt(heatmaptableWOpv, id.vars = "Symbol", measure.vars = c("APC", "BCell", "CD4", "CD8", "TReg"))
#change level order to stay in ordered way by better than
heatmaptableWOpv.m$Symbol <- factor(heatmaptableWOpv.m$Symbol, levels = heatmaptableordered$Symbol)


##gradientn
#in between gray is zero, whites and grays have to be extremely close, in between white and blue is bottom value before purple (use the quantile)
pals <- c("tomato2", "white", "white", "gray90", "gray90", "white", "white", "deepskyblue2", "deepskyblue2", "purple", "purple")
vals <- c(1, 0.717, 0.716, 0.715, 0.71428571, 0.713, 0.712, 0.05, 0.0499, 0.0498, 0) # zero at -71.428571
brks <- c(4, 0, -9)
#labels <- c(3, 0, -13, -267)


chr1HMint <- 
ggplot(heatmaptableWOpv.m, aes(variable, Symbol, fill = value)) +
  geom_tile(color = "white") +
  #theme_bw() +
  scale_fill_gradientn(name = "fold \nchange", 
                       colours = pals,
                       values = vals, 
                       limits = c(-10, 4), 
                       na.value = "purple", 
                       #limits = c(floor(range[1]), ceiling(range[2])),
                       breaks = brks) +
                       #labels = labels) +
  ggtitle(label = "Chr 1") + 
  xlab("Cell Type") +
  ylab("Chr 1 Genes") +
  theme(axis.text = element_text(size=30), title = element_text(size = 30),
        axis.title= element_text(size=30), 
        legend.text = element_text(size=30),
        legend.title = element_text(size = 30),
        panel.background = element_rect(fill = "white"), 
        axis.ticks.y = element_blank()) +
  coord_fixed(ratio = 1/3)
#ggsave("Chr1_heatmap.svg", height = 10, width = 10, units = "in")
#ggsave("Chr1_heatmap.pdf")
```



```{r ggplot for heatmap chr2 }
#redo the heatmaptables first using pareto AND top genes
#chr. 2


heatmaptable2APC <- 
  final.tableTRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref[[1]]), as.character(top10_1[[1]])))
  
heatmaptable2BCELL <- 
  final.table2TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref2[[1]]), as.character(top10_2[[1]])))

heatmaptable2CD4 <-
  final.table3TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref3[[1]]), as.character(top10_3[[1]])))

heatmaptable2CD8 <- 
  final.table4TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref4[[1]]), as.character(top10_4[[1]])))

heatmaptable2TREG <- 
  final.table5TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref5[[1]]), as.character(top10_5[[1]])))

#get FC for each cell type from all the tables
heatmaptable2 <- 
  rbind((cbind(heatmaptable2APC$Symbol,heatmaptable2APC$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2APC$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2APC$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2APC$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2APC$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2APC$BetterThan)), 
        (cbind(heatmaptable2BCELL$Symbol, heatmaptable2BCELL$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2BCELL$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2BCELL$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2BCELL$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2BCELL$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2BCELL$BetterThan)), 
        (cbind(heatmaptable2CD4$Symbol, heatmaptable2CD4$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2CD4$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2CD4$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2CD4$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2CD4$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2CD4$BetterThan)), 
        (cbind(heatmaptable2CD8$Symbol, heatmaptable2CD8$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2CD8$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2CD8$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2CD8$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2CD8$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2CD8$BetterThan)), 
        (cbind(heatmaptable2TREG$Symbol, heatmaptable2TREG$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2TREG$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2TREG$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2TREG$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2TREG$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2TREG$BetterThan)))

#change column names to be able to work with
heatmaptable2 <- data.frame(heatmaptable2, stringsAsFactors = FALSE) #have to do this so the levels don't cary over
colnames(heatmaptable2) <- c("Symbol", "FCapc", "FCbcell", "FCcd4", "FCcd8", "FCtreg", "BetterThan")

#take out duplicates and just use top ranked line
heatmaptable2 <- 
  heatmaptable2 %>%
  group_by(Symbol) %>%
  top_n(1, BetterThan) %>%
  distinct(Symbol, .keep_all= TRUE) %>%
  ungroup()

# have to turn better than into numeric first to be able to order
heatmaptable2$BetterThan <- as.numeric(heatmaptable2$BetterThan)
#order by better than
heatmaptable2ordered <- as.data.frame(heatmaptable2[order(as.numeric(as.character(heatmaptable2$BetterThan)), decreasing = FALSE),][ , 1:6])

#have to reshape table
heatmaptable2ordered$FCapc <- as.numeric(as.character((heatmaptable2ordered$FCapc)))
heatmaptable2ordered$FCbcell <- as.numeric(as.character((heatmaptable2ordered$FCbcell)))
heatmaptable2ordered$FCcd4 <- as.numeric(as.character((heatmaptable2ordered$FCcd4)))
heatmaptable2ordered$FCcd8 <- as.numeric(as.character((heatmaptable2ordered$FCcd8)))
heatmaptable2ordered$FCtreg <- as.numeric(as.character((heatmaptable2ordered$FCtreg)))


#heatmap

#get range to be able to find the limits for ggplot (then can use this to do breaks)
allFCch2 <- c(heatmaptable2ordered$FCapc, heatmaptable2ordered$FCbcell, heatmaptable2ordered$FCcd4, heatmaptable2ordered$FCcd8, heatmaptable2ordered$FCtreg)
RANGEallFCch2 <- range(allFCch2) # -5.9713 52.2411 (-6, 53)


#find where to put the breaks - this is just to visualize and map what number to put for which break value
BreaksChr2Numbers <- as.data.frame(seq(7, -6)) # INSTEAD USE QUANT below for extreme values and min range for the other end
BreaksChr2Numbers$values <- seq(-100, 0, length.out = 14)

# NEW IDEA - use 95% and 5%
QUANTallFCch2 <- quantile(allFCch2, c(.05, .95))
# 5% -4.487582  and 95% is 6.801857 


#pick out the gene/cell combo that have sig p values 
heatmaptable2Wpv <- heatmaptable2ordered
heatmaptable2Wpv$APCpv <- final.table$APCpv[match(heatmaptable2Wpv$Symbol, final.table$Symbol)]
heatmaptable2Wpv$BCELLpv <- final.table$BCELLpv[match(heatmaptable2Wpv$Symbol, final.table$Symbol)]
heatmaptable2Wpv$CD4pv <- final.table$CD4pv[match(heatmaptable2Wpv$Symbol, final.table$Symbol)]
heatmaptable2Wpv$CD8pv <- final.table$CD8pv[match(heatmaptable2Wpv$Symbol, final.table$Symbol)]
heatmaptable2Wpv$TREGpv <- final.table$TREGpv[match(heatmaptable2Wpv$Symbol, final.table$Symbol)]

#turn insignificant p values to zero in the fold change
heatmaptable2Wpv$FCapc[heatmaptable2Wpv$APCpv > 0.05] <- 0
heatmaptable2Wpv$FCbcell[heatmaptable2Wpv$BCELLpv > 0.05] <- 0
heatmaptable2Wpv$FCcd4[heatmaptable2Wpv$CD4pv > 0.05] <- 0
heatmaptable2Wpv$FCcd8[heatmaptable2Wpv$CD8pv > 0.05] <- 0
heatmaptable2Wpv$FCtreg[heatmaptable2Wpv$TREGpv > 0.05] <- 0

# #dataframe with just fc values filtered by if the p value was significant
# heatmaptable2Wpv[,2:6] %>% filter(heatmaptable2Wpv$APCpv < 0.05)
# range(mutate_all(heatmaptable2[,2:6], function(x) as.numeric(as.character(x))))

#melt new heatmaptable2 with NAs
heatmaptable2WOpv <- as.data.frame(heatmaptable2Wpv[, 1:6])
colnames(heatmaptable2WOpv) <- c("Symbol", "APC", "BCell", "CD4", "CD8", "TReg")
heatmaptable2WOpv.m <- melt(heatmaptable2WOpv, id.vars = "Symbol", measure.vars = c("APC", "BCell", "CD4", "CD8", "TReg"))
#change level order to stay in ordered way by better than
heatmaptable2WOpv.m$Symbol <- factor(heatmaptable2WOpv.m$Symbol, levels = heatmaptable2ordered$Symbol)
##gradientn
#vals are in between pals, and zero is between white and grey on the left, use quant for between plum and tomato
#in between gray is zero, whites and grays have to be extremely close, in between white and tomato is bottom value before plum (use the quantile)
pals2 <- c("plum2", "plum2", "tomato2", "white", "white", "white", "gray90","gray90", "white", "white", "deepskyblue2") #zero at -46.153846
vals2 <- c(1, 0.975, 0.9749, 0.464, 0.463, 0.462, 0.46153846, 0.460, 0.459, 0.458, 0)
 # 1, 0.985, 0.9849, 0.529, 0.528, 0.527, 0.52631579, 0.525, 0.524, 0.523, 0) #zero at -52.631579
brks2 <- c(6, 0, -6)

chr2HMint <- 
ggplot(heatmaptable2WOpv.m, aes(variable, Symbol, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradientn(name = "fold \nchange", 
                       colours = pals2,
                       values = vals2, 
                       limits = c(-6, 7), 
                       na.value = "plum2", 
                       breaks = brks2) +
  ggtitle(label = "Chr 2") + 
  xlab("Cell Type") +
  ylab("Chr 2 Genes") +
  theme(axis.text = element_text(size=30), title = element_text(size = 30),
        axis.title= element_text(size=30), 
        legend.text = element_text(size=30),
        legend.title = element_text(size = 30),
        panel.background = element_rect(fill = "white"), 
        axis.ticks.y = element_blank()) +
  coord_fixed(ratio = 1/3)

#ggsave("Chr2_heatmap.svg", height = 10, width = 10, units = "in")
#ggsave("Chr2_heatmap.pdf")
```



```{r heatmap same plotsize width}
#using ggarange
# ggarrange(chr1HM, chr2HM, ncol = 1, heights = 10, widths = 10)
# ggsave("chr1and2.svg")


#using align_plots
ap <- align_plots(chr1HM, chr2HM, align="v")

ggdraw(ap[[1]])
ggsave("chr1aligned.svg", height = 10, width = 10, units = "in")
#align_plots` returns a list of plots that we can draw seperately, but whose panels will still be vertically aligned on the page.

ggdraw(ap[[2]])
ggsave("chr2aligned.svg", height = 10, width = 10, units = "in")
```








```{r ggplot for heatmap 1:1 overlap chr1}

#IBDGWAS 1:1 genes (from DK)
chr1List <- c("Atp1b1", "Cacna1s", "Cd28", "F5", "Gpr35", "Nme7", "Ptprc", "Selp", "Slamf8")
chr2list <- c("Ada", "Asxl1", "Cd40", "Il2ra", "Itga4", "Kif3b", "Pkig", "Serinc3", "Tm9sf4", "Ttpal")

#but what about just the original list after we put more chr1 and 2
#were these in the original SVM training?
inTraining <- toupper(ALLprefALLtop[[1]]) %in% as.character(IBDGWASmouseEntrez[["name"]])
#use ALLprefALLtop[[1]][inTraining] to see which were used in training (toupper is for case sensitivity)

#all sig chr1 in GWAS
chr1final.tableSIG <- final.tableSIG %>% filter(Chr==1)
GWASchr1SIGapc <- IBDGWASmouseEntrez$name %in% toupper(chr1final.tableSIG$Symbol)
#IBDGWASmouseEntrez$name[GWASchr1SIGapc]
chr1final.table2SIG <- final.table2SIG %>% filter(Chr==1)
GWASchr1SIGbcell <- IBDGWASmouseEntrez$name %in% toupper(chr1final.table2SIG$Symbol)
chr1final.table3SIG <- final.table3SIG %>% filter(Chr==1)
GWASchr1SIGcd4 <- IBDGWASmouseEntrez$name %in% toupper(chr1final.table3SIG$Symbol)
chr1final.table4SIG <- final.table4SIG %>% filter(Chr==1)
GWASchr1SIGcd8 <- IBDGWASmouseEntrez$name %in% toupper(chr1final.table4SIG$Symbol)
chr1final.table5SIG <- final.table5SIG %>% filter(Chr==1)
GWASchr1SIGtreg <- IBDGWASmouseEntrez$name %in% toupper(chr1final.table5SIG$Symbol)


chr2final.tableSIG <- final.tableSIG %>% filter(Chr==2)
GWASchr2SIGapc <- IBDGWASmouseEntrez$name %in% toupper(chr2final.tableSIG$Symbol)
#IBDGWASmouseEntrez$name[GWASchr1SIGapc]
chr2final.table2SIG <- final.table2SIG %>% filter(Chr==2)
GWASchr2SIGbcell <- IBDGWASmouseEntrez$name %in% toupper(chr2final.table2SIG$Symbol)
chr2final.table3SIG <- final.table3SIG %>% filter(Chr==2)
GWASchr2SIGcd4 <- IBDGWASmouseEntrez$name %in% toupper(chr2final.table3SIG$Symbol)
chr2final.table4SIG <- final.table4SIG %>% filter(Chr==2)
GWASchr2SIGcd8 <- IBDGWASmouseEntrez$name %in% toupper(chr2final.table4SIG$Symbol)
chr2final.table5SIG <- final.table5SIG %>% filter(Chr==2)
GWASchr2SIGtreg <- IBDGWASmouseEntrez$name %in% toupper(chr2final.table5SIG$Symbol)

chr2final.tableSIG <- final
GWASch1and2 <- IBDGWASmouseEntrez$name %in% toupper(DEGchr1and2$Symbol)
#IBDGWASmouseEntrez$name[GWASch1and2]



chr1listheatmaptableAPC <- 
  final.tableTRANS %>%
  filter(Symbol %in% chr1List)
  
chr1listheatmaptableBCELL <- 
  final.table2TRANS %>%
  filter(Symbol %in% chr1List)

chr1listheatmaptableCD4 <-
  final.table3TRANS %>%
 filter(Symbol %in% chr1List)

chr1listheatmaptableCD8 <- 
  final.table4TRANS %>%
  filter(Symbol %in% chr1List)

chr1listheatmaptableTREG <- 
  final.table5TRANS %>%
  filter(Symbol %in% chr1List)

#get FC for each cell type from all the tables
chr1listheatmaptable <- 
  rbind((cbind(chr1listheatmaptableAPC$Symbol,chr1listheatmaptableAPC$Fold.Change.PWD...APCs.vs..B6...APCs., chr1listheatmaptableAPC$Fold.Change.PWD...Bcells.vs..B6...Bcells., chr1listheatmaptableAPC$Fold.Change.PWD...CD4.vs..B6...CD4., chr1listheatmaptableAPC$Fold.Change.PWD...CD8.vs..B6...CD8., chr1listheatmaptableAPC$Fold.Change.PWD...Tregs.vs..B6...Tregs., chr1listheatmaptableAPC$BetterThan)), 
        (cbind(chr1listheatmaptableBCELL$Symbol, chr1listheatmaptableBCELL$Fold.Change.PWD...APCs.vs..B6...APCs., chr1listheatmaptableBCELL$Fold.Change.PWD...Bcells.vs..B6...Bcells., chr1listheatmaptableBCELL$Fold.Change.PWD...CD4.vs..B6...CD4., chr1listheatmaptableBCELL$Fold.Change.PWD...CD8.vs..B6...CD8., chr1listheatmaptableBCELL$Fold.Change.PWD...Tregs.vs..B6...Tregs., chr1listheatmaptableBCELL$BetterThan)), 
        (cbind(chr1listheatmaptableCD4$Symbol, chr1listheatmaptableCD4$Fold.Change.PWD...APCs.vs..B6...APCs., chr1listheatmaptableCD4$Fold.Change.PWD...Bcells.vs..B6...Bcells., chr1listheatmaptableCD4$Fold.Change.PWD...CD4.vs..B6...CD4., chr1listheatmaptableCD4$Fold.Change.PWD...CD8.vs..B6...CD8., chr1listheatmaptableCD4$Fold.Change.PWD...Tregs.vs..B6...Tregs., chr1listheatmaptableCD4$BetterThan)), 
        (cbind(chr1listheatmaptableCD8$Symbol, chr1listheatmaptableCD8$Fold.Change.PWD...APCs.vs..B6...APCs., chr1listheatmaptableCD8$Fold.Change.PWD...Bcells.vs..B6...Bcells., chr1listheatmaptableCD8$Fold.Change.PWD...CD4.vs..B6...CD4., chr1listheatmaptableCD8$Fold.Change.PWD...CD8.vs..B6...CD8., chr1listheatmaptableCD8$Fold.Change.PWD...Tregs.vs..B6...Tregs., chr1listheatmaptableCD8$BetterThan)), 
        (cbind(chr1listheatmaptableTREG$Symbol, chr1listheatmaptableTREG$Fold.Change.PWD...APCs.vs..B6...APCs., chr1listheatmaptableTREG$Fold.Change.PWD...Bcells.vs..B6...Bcells., chr1listheatmaptableTREG$Fold.Change.PWD...CD4.vs..B6...CD4., chr1listheatmaptableTREG$Fold.Change.PWD...CD8.vs..B6...CD8., chr1listheatmaptableTREG$Fold.Change.PWD...Tregs.vs..B6...Tregs., chr1listheatmaptableTREG$BetterThan)))

#change column names to be able to work with
chr1listheatmaptable <- as.data.frame(chr1listheatmaptable)
colnames(chr1listheatmaptable) <- c("Symbol", "FCapc", "FCbcell", "FCcd4", "FCcd8", "FCtreg", "BetterThan")

#take out duplicates and just use top ranked line
chr1listheatmaptable <- 
  chr1listheatmaptable %>%
  group_by(Symbol) %>%
  top_n(1, BetterThan) %>%
  distinct(Symbol, .keep_all= TRUE) %>%
  ungroup()

#drop unused levels 
chr1listheatmaptable <- droplevels.data.frame(chr1listheatmaptable)
#order by better than
chr1listheatmaptableordered <- as.data.frame(chr1listheatmaptable[order(as.numeric(as.character(chr1listheatmaptable$BetterThan)), decreasing = FALSE),][ , 1:6])

#have to reshape table
chr1listheatmaptableordered$FCapc <- as.numeric(as.character((chr1listheatmaptableordered$FCapc)))
chr1listheatmaptableordered$FCbcell <- as.numeric(as.character((chr1listheatmaptableordered$FCbcell)))
chr1listheatmaptableordered$FCcd4 <- as.numeric(as.character((chr1listheatmaptableordered$FCcd4)))
chr1listheatmaptableordered$FCcd8 <- as.numeric(as.character((chr1listheatmaptableordered$FCcd8)))
chr1listheatmaptableordered$FCtreg <- as.numeric(as.character((chr1listheatmaptableordered$FCtreg)))

#melt to be able to use in ggplot
chr1listheatmaptableordered.m <- melt(chr1listheatmaptableordered)
#change level order to stay in ordered way by better than
chr1listheatmaptableordered.m$Symbol <- factor(chr1listheatmaptableordered.m$Symbol, levels = chr1listheatmaptableordered.m$Symbol[order(chr1listheatmaptableordered$Symbol)])


#heatmap

#get range to be able to find the limits for ggplot (then can use this to do breaks)
allFCch1list <- c(chr1listheatmaptableordered$FCapc, chr1listheatmaptableordered$FCbcell, chr1listheatmaptableordered$FCcd4, chr1listheatmaptableordered$FCcd8, chr1listheatmaptableordered$FCtreg)
chr1range <- range(allFCch1list)
# range = -10 to 53
#find second last value for break
FindingSecondInRange2 <- allFCch2[allFCch2!=max(range)]
#use min(FindingSecondInRange) to find the second to last number in range
###### use hist(chr1listheatmaptableordered.m$value) instead because there are multiple higher values


#find where to put the breaks - this is just to visualize and map what number to put for which break value
Breakschr1list <- as.data.frame(seq(4, -8))
Breakschr1list$values <- seq(-100, 0, length.out = 13)

#pick out the gene/cell combo that have sig p values 
chr1listheatmaptableWpv <- chr1listheatmaptableordered
chr1listheatmaptableWpv$APCpv <- final.table$APCpv[match(chr1listheatmaptableWpv$Symbol, final.table$Symbol)]
chr1listheatmaptableWpv$BCELLpv <- final.table$BCELLpv[match(chr1listheatmaptableWpv$Symbol, final.table$Symbol)]
chr1listheatmaptableWpv$CD4pv <- final.table$CD4pv[match(chr1listheatmaptableWpv$Symbol, final.table$Symbol)]
chr1listheatmaptableWpv$CD8pv <- final.table$CD8pv[match(chr1listheatmaptableWpv$Symbol, final.table$Symbol)]
chr1listheatmaptableWpv$TREGpv <- final.table$TREGpv[match(chr1listheatmaptableWpv$Symbol, final.table$Symbol)]

#turn insignificant p values to zero in the fold change
chr1listheatmaptableWpv$FCapc[chr1listheatmaptableWpv$APCpv > 0.05] <- 0
chr1listheatmaptableWpv$FCbcell[chr1listheatmaptableWpv$BCELLpv > 0.05] <- 0
chr1listheatmaptableWpv$FCcd4[chr1listheatmaptableWpv$CD4pv > 0.05] <- 0
chr1listheatmaptableWpv$FCcd8[chr1listheatmaptableWpv$CD8pv > 0.05] <- 0
chr1listheatmaptableWpv$FCtreg[chr1listheatmaptableWpv$TREGpv > 0.05] <- 0

# #dataframe with just fc values filtered by if the p value was significant
# chr1listheatmaptableWpv[,2:6] %>% filter(chr1listheatmaptableWpv$APCpv < 0.05)
# range(mutate_all(chr1listheatmaptable[,2:6], function(x) as.numeric(as.character(x))))

#melt new chr1listheatmaptable with NAs
chr1listheatmaptableWOpv <- as.data.frame(chr1listheatmaptableWpv[, 1:6])
colnames(chr1listheatmaptableWOpv) <- c("Symbol", "APC", "BCell", "CD4", "CD8", "TReg")
chr1listheatmaptableWOpv.m <- melt(chr1listheatmaptableWOpv, id.vars = "Symbol", measure.vars = c("APC", "BCell", "CD4", "CD8", "TReg"))

#change level order to stay in ordered way by better than
chr1listheatmaptableWOpv.m$Symbol <- factor(chr1listheatmaptableWOpv.m$Symbol, levels = chr1listheatmaptableordered$Symbol)

##gradientn
palschr1 <- c("tomato3", "white", "gray85", "white", "deepskyblue2")
valschr1 <- c(1, 0.67, 0.66, 0.65, 0)

ggplot(chr1listheatmaptableWOpv.m, aes(variable, Symbol, fill = value)) +
  geom_tile(color = "white") +
  #theme_bw() +
  scale_fill_gradientn(name = "fold change", 
                       colours = palschr1,
                       values = valschr1, 
                       limits = c(-8, 4)) +
                       #limits = c(floor(range[1]), ceiling(range[2])),
                       #breaks = brks, 
                       #labels = labels) +
  ggtitle("IBD Candidates 1:1 \n(Intestinal Funtional Network)") + 
  xlab("Cell Type") +
  ylab("Chromosome 1 \nGenes") +
  theme(axis.text = element_text(size=14),
        axis.title= element_text(size=17), 
        panel.background = element_rect(fill = "white"), 
        axis.ticks.y = element_blank())

ggsave("IBD1to1_Chr1_heatmap.svg")
ggsave("IBD1to1_Chr1_heatmap.pdf")
```
















######this is where all the other heatmap attempts begin - don't know if need any of this later





```{r don't use this one}
#chr. 1


heatmaptableAPC <- 
  final.tableTRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref[[1]]), as.character(top10_1[[1]])))
  

heatmaptableBCELL <- 
  final.table2TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref2[[1]]), as.character(top10_2[[1]])))

heatmaptableCD4 <-
  final.table3TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref3[[1]]), as.character(top10_3[[1]])))

heatmaptableCD8 <- 
  final.table4TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref4[[1]]), as.character(top10_4[[1]])))

heatmaptableTREG <- 
  final.table5TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% c(as.character(pref5[[1]]), as.character(top10_5[[1]])))

heatmaptable <- 
  rbind((cbind(heatmaptableAPC$Symbol,heatmaptableAPC$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableAPC$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableAPC$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableAPC$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableAPC$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableAPC$BetterThan)), 
        (cbind(heatmaptableBCELL$Symbol, heatmaptableBCELL$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableBCELL$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableBCELL$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableBCELL$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableBCELL$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableBCELL$BetterThan)), 
        (cbind(heatmaptableCD4$Symbol, heatmaptableCD4$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableCD4$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableCD4$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableCD4$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableCD4$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableCD4$BetterThan)), 
        (cbind(heatmaptableCD8$Symbol, heatmaptableCD8$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableCD8$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableCD8$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableCD8$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableCD8$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableCD8$BetterThan)), 
        (cbind(heatmaptableTREG$Symbol, heatmaptableTREG$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableTREG$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableTREG$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableTREG$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableTREG$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptableTREG$BetterThan)))


colnames(heatmaptable) <- c("Symbol", "FCapc", "FCbcell", "FCcd4", "FCcd8", "FCtreg", "BetterThan")
heatmaptable <- unique(heatmaptable)
rownames(heatmaptable) <- heatmaptable[,1]
class(heatmaptable) <- "numeric"
heatmaptable <- heatmaptable[, 2:7]
heatmaptableordered <- heatmaptable[order(-heatmaptable[,6]),]

##note - there are two duplicates in heatmaptable for chr 1 because two of the same genes were filtered in different cell types for their p value, but one of the probes had one set of FC values, and the other probe had a diff set, and in one cell the first p value corresponding to those FCs was lower, and then in another cell a diff p value was lower - hence why two different set of FCs

#chr 2

heatmaptable2APC <- 
  final.tableTRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref[[1]]), as.character(top10_1[[1]])))

heatmaptable2BCELL <- 
  final.table2TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref2[[1]]), as.character(top10_2[[1]])))

heatmaptable2CD4 <-
  final.table3TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref3[[1]]), as.character(top10_3[[1]])))

heatmaptable2CD8 <- 
  final.table4TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref4[[1]]), as.character(top10_4[[1]])))

heatmaptable2TREG <- 
  final.table5TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% c(as.character(pref5[[1]]), as.character(top10_5[[1]])))

      
heatmaptable2 <- rbind((cbind(heatmaptable2APC$Symbol,heatmaptable2APC$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2APC$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2APC$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2APC$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2APC$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2APC$BetterThan)), 
                       (cbind(heatmaptable2BCELL$Symbol, heatmaptable2BCELL$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2BCELL$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2BCELL$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2BCELL$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2BCELL$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2BCELL$BetterThan)), 
                       (cbind(heatmaptable2CD4$Symbol, heatmaptable2CD4$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2CD4$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2CD4$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2CD4$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2CD4$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2CD4$BetterThan)), 
                       (cbind(heatmaptable2CD8$Symbol, heatmaptable2CD8$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2CD8$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2CD8$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2CD8$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2CD8$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2CD8$BetterThan)), 
                       (cbind(heatmaptable2TREG$Symbol, heatmaptable2TREG$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2TREG$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2TREG$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2TREG$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2TREG$Fold.Change.PWD...Tregs.vs..B6...Tregs., heatmaptable2TREG$BetterThan)))

colnames(heatmaptable2) <- c("Symbol", "FCapc", "FCbcell", "FCcd4", "FCcd8", "FCtreg", "BetterThan")
heatmaptable2 <- unique(heatmaptable2)
rownames(heatmaptable2) <- heatmaptable2[,1]
class(heatmaptable2) <- "numeric"
heatmaptable2 <- heatmaptable2[, 2:7]
heatmaptable2ordered <- heatmaptable2[order(-heatmaptable2[,6]),]

```
## HEATMAP CHR 1

```{r don't use this one either}
##make heatmap
#CHR 1
mpto1t5 <- heatmaptableordered[,1:5]
lessthan2 <- mpto1t5[abs(heatmaptableordered[,1:5]) <= 2]
lessthan2 <- heatmaptableordered %in% lessthan2
heatmaptableordered[lessthan2] <- 0


#quantile breaks: 
quantileRange <- quantile(heatmaptableordered[,1:5], probs = seq(0, 1, 0.01))
paletteBreaks <- seq(quantileRange["5%"], quantileRange["95%"], 0.1)


breaksList = seq(-55, 55, by = 1)

pheatmap(heatmaptableordered[,1:5], 
         cluster_rows = F, 
         cluster_cols = F, 
         show_rownames = T, 
         show_colnames = T, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(breaksList)), # Defines the vector of colors for the legend (it has to be of the same lenght of breaksList) 
         breaks = breaksList) # Sets the breaks of the color scale as in breaksList)




#change row/gene name to have final score
for(i in 1:length(heatmaptableordered[,1])){
  name.i <- as.character(rownames(heatmaptableordered)[i])
  finalscore.i <- round(heatmaptableordered[i,6], 2)
  rownames(heatmaptableordered)[i] <- paste(name.i, finalscore.i, sep =" : ")
}

#pheatmap done with Z score
pdf("chr1_heatmap.pdf")
pheatmap(heatmaptableordered[,1:5], 
         cluster_rows = F, 
         cluster_cols = F, 
         show_rownames = T, 
         show_colnames = T, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(paletteBreaks)), 
         breaks = paletteBreaks, 
         main = "Chromosome 1: \nheatmap of fold change for pareto front genes\n ranked by final score (-log FP + -log DEGpv)")
dev.off()
```


##test - redoing heatmaptables, and then using ggplot instead **just the next two chunks - regroups after that


## HEATMAP CHR2

```{r this was another test}
mpto1t52 <- heatmaptable2ordered[,1:5]
lessthan2 <- mpto1t52[abs(heatmaptable2ordered[,1:5]) <= 2]
lessthan2 <- heatmaptable2ordered %in% lessthan2
heatmaptable2ordered[lessthan2] <- 0


breaksList = seq(-50, 50, by = 1)
#pheatmap(heatmaptable2ordered[,1:5], cluster_rows = F, cluster_cols = F, show_rownames = T, show_colnames = T, color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(breaksList)), # Defines the vector of colors for the legend (it has to be of the same lenght of breaksList)
 #        breaks = breaksList) # Sets the breaks of the color scale as in breaksList)

#rename gene/row to have final score
for(i in 1:length(heatmaptable2ordered[,1])){
  name.i <- as.character(rownames(heatmaptable2ordered)[i])
  finalscore.i <- round(heatmaptable2ordered[i,6], 2)
  rownames(heatmaptable2ordered)[i] <- paste(name.i, finalscore.i, sep =" : ")
}
#done with Z score
pdf("chr2_heatmap.pdf")
pheatmap(heatmaptable2ordered[,1:5], cluster_rows = F, cluster_cols = F, show_rownames = T, show_colnames = T,scale = "column", color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(breaksList)), main = "Chromosome 2: \nheatmap of fold change for pareto front genes\n ranked by final score (-log FP + -log DEGpv)")
dev.off()
```


#making heatmap table from all top 10 only (not accounting for any others on pareto front)
```{r heatmap top 10}
#chr. 1

heatmaptableTOPAPC <- 
  final.tableTRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% as.character(top10_1[[1]]))

heatmaptableTOPBCELL <- 
  final.table2TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% as.character(top10_2[[1]]))

heatmaptableTOPCD4 <-
  final.table3TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% as.character(top10_3[[1]]))

heatmaptableTOPCD8 <- 
  final.table4TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% as.character(top10_4[[1]]))

heatmaptableTOPTREG <- 
  final.table5TRANS %>%
  filter(Chr ==1) %>%
  filter(Symbol %in% as.character(top10_5[[1]]))

heatmaptableTOP10 <- 
  rbind((cbind(heatmaptableTOPAPC$Symbol,heatmaptableTOPAPC$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableTOPAPC$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableTOPAPC$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableTOPAPC$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableTOPAPC$Fold.Change.PWD...Tregs.vs..B6...Tregs.)), 
        (cbind(heatmaptableTOPBCELL$Symbol, heatmaptableTOPBCELL$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableTOPBCELL$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableTOPBCELL$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableTOPBCELL$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableTOPBCELL$Fold.Change.PWD...Tregs.vs..B6...Tregs.)), 
        (cbind(heatmaptableTOPCD4$Symbol, heatmaptableTOPCD4$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableTOPCD4$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableTOPCD4$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableTOPCD4$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableTOPCD4$Fold.Change.PWD...Tregs.vs..B6...Tregs.)), 
        (cbind(heatmaptableTOPCD8$Symbol, heatmaptableTOPCD8$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableTOPCD8$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableTOPCD8$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableTOPCD8$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableTOPCD8$Fold.Change.PWD...Tregs.vs..B6...Tregs.)), 
        (cbind(heatmaptableTOPTREG$Symbol, heatmaptableTOPTREG$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptableTOPTREG$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptableTOPTREG$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptableTOPTREG$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptableTOPTREG$Fold.Change.PWD...Tregs.vs..B6...Tregs.)))


colnames(heatmaptableTOP10) <- c("Symbol", "FCapc", "FCbcell", "FCcd4", "FCcd8", "FCtreg")
heatmaptableTOP10 <- unique(heatmaptableTOP10)


rownames(heatmaptableTOP10) <- heatmaptableTOP10[,1]
class(heatmaptableTOP10) <- "numeric"
heatmaptableTOP10 <- heatmaptableTOP10[, 2:6]
heatmaptableTOP10ordered <- heatmaptableTOP10[order(-heatmaptableTOP10[,6]),]

```

```{r heatmap top 10}
##make heatmap
#CHR 1
mpto1t5 <- heatmaptableTOP10[,1:5]
lessthan2 <- mpto1t5[abs(heatmaptableTOP10[,1:5]) <= 2]
lessthan2 <- heatmaptableTOP10 %in% lessthan2
heatmaptableTOP10[lessthan2] <- 0


#quantile breaks: 
quantileRange <- quantile(heatmaptableTOP10[,1:5], probs = seq(0, 1, 0.01))
paletteBreaks <- seq(quantileRange["5%"], quantileRange["95%"], 0.1)


breaksList = seq(-10, 3, by = 1)

pheatmap(heatmaptableTOP10[,1:5], 
         cluster_rows = F, 
         cluster_cols = F, 
         show_rownames = T, 
         show_colnames = T, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(breaksList)), # Defines the vector of colors for the legend (it has to be of the same lenght of breaksList) 
         breaks = breaksList) # Sets the breaks of the color scale as in breaksList)
ggsave("HL_chr1_heatmap.pdf")

pheatmap(heatmaptableTOP10, cluster_rows = F, cluster_cols = F, show_rownames = T, show_colnames = T, colors = colors.from.values(heatmaptableTOP10))


pdf("HL_chr1_heatmap.pdf")
pheatmap(heatmaptableTOP10, 
         cluster_rows = F, 
         cluster_cols = F, 
         show_rownames = T, 
         show_colnames = T, 
         color = colors.from.values(heatmaptableTOP10[,1], split.at.vals = TRUE))



#change row/gene name to have final score
for(i in 1:length(heatmaptableTOP10[,1])){
  name.i <- as.character(rownames(heatmaptableTOP10)[i])
  finalscore.i <- round(heatmaptableTOP10[i,6], 2)
  rownames(heatmaptableTOP10)[i] <- paste(name.i, finalscore.i, sep =" : ")
}

#pheatmap done with Z score
pdf("chr1_heatmap.pdf")
pheatmap(heatmaptableTOP10[,1:5], 
         cluster_rows = F, 
         cluster_cols = F, 
         show_rownames = T, 
         show_colnames = T, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(paletteBreaks)), 
         breaks = paletteBreaks, 
         main = "Chromosome 1: \nheatmap of fold change for pareto front genes\n ranked by final score (-log FP + -log DEGpv)")
dev.off()
```

```{r pheatmap instead}
pdf("chr1_heatmap.pdf")
pheatmap(heatmaptableTOP10[,1:5], 
         cluster_rows = F, 
         cluster_cols = F, 
         show_rownames = T, 
         show_colnames = T, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(breaksList)), # Defines the vector of colors for the legend (it has to be of the same lenght of breaksList) 
         breaks = breaksList) # Sets the breaks of the color scale as in breaksList)
dev.off()
```
```{r}
pdf("chr1_heatmap.pdf")
pheatmap(heatmaptable2TOP10[,1:5], 
         cluster_rows = F, 
         cluster_cols = F, 
         show_rownames = T, 
         show_colnames = T, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(breaksList)), # Defines the vector of colors for the legend (it has to be of the same lenght of breaksList) 
         breaks = breaksList) # Sets the breaks of the color scale as in breaksList)
dev.off()
```

```{r}



#chr. 2

heatmaptable2TOPAPC <- 
  final.tableTRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% as.character(top10_1[[1]]))

heatmaptable2TOPBCELL <- 
  final.table2TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% as.character(top10_2[[1]]))

heatmaptable2TOPCD4 <-
  final.table3TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% as.character(top10_3[[1]]))

heatmaptable2TOPCD8 <- 
  final.table4TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% as.character(top10_4[[1]]))

heatmaptable2TOPTREG <- 
  final.table5TRANS %>%
  filter(Chr ==2) %>%
  filter(Symbol %in% as.character(top10_5[[1]]))

heatmaptable2TOP10 <- 
  rbind((cbind(heatmaptable2TOPAPC$Symbol,heatmaptable2TOPAPC$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2TOPAPC$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2TOPAPC$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2TOPAPC$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2TOPAPC$Fold.Change.PWD...Tregs.vs..B6...Tregs.)), 
        (cbind(heatmaptable2TOPBCELL$Symbol, heatmaptable2TOPBCELL$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2TOPBCELL$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2TOPBCELL$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2TOPBCELL$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2TOPBCELL$Fold.Change.PWD...Tregs.vs..B6...Tregs.)), 
        (cbind(heatmaptable2TOPCD4$Symbol, heatmaptable2TOPCD4$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2TOPCD4$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2TOPCD4$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2TOPCD4$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2TOPCD4$Fold.Change.PWD...Tregs.vs..B6...Tregs.)), 
        (cbind(heatmaptable2TOPCD8$Symbol, heatmaptable2TOPCD8$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2TOPCD8$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2TOPCD8$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2TOPCD8$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2TOPCD8$Fold.Change.PWD...Tregs.vs..B6...Tregs.)), 
        (cbind(heatmaptable2TOPTREG$Symbol, heatmaptable2TOPTREG$Fold.Change.PWD...APCs.vs..B6...APCs., heatmaptable2TOPTREG$Fold.Change.PWD...Bcells.vs..B6...Bcells., heatmaptable2TOPTREG$Fold.Change.PWD...CD4.vs..B6...CD4., heatmaptable2TOPTREG$Fold.Change.PWD...CD8.vs..B6...CD8., heatmaptable2TOPTREG$Fold.Change.PWD...Tregs.vs..B6...Tregs.)))


colnames(heatmaptable2TOP10) <- c("Symbol", "FCapc", "FCbcell", "FCcd4", "FCcd8", "FCtreg")
heatmaptable2TOP10 <- unique(heatmaptable2TOP10)
rownames(heatmaptable2TOP10) <- heatmaptable2TOP10[,1]
class(heatmaptable2TOP10) <- "numeric"
heatmaptable2TOP10 <- heatmaptable2TOP10[, 2:7]
heatmaptable2TOP10ordered <- heatmaptable2TOP10[order(-heatmaptable2TOP10[,6]),]

##note - there are two duplicates in heatmaptable2TOP10 for chr 1 because two of the same genes were filtered in different cell types for their p value, but one of the probes had one set of FC values, and the other probe had a diff set, and in one cell the first p value corresponding to those FCs was lower, and then in another cell a diff p value was lower - hence why two different set of FCs
```

```{r more pheatmap}
breaksList2 = seq(-10, 16, by = 1)

pdf("chr2_heatmap.pdf")
pheatmap(heatmaptable2TOP10[, 2:6], 
         cluster_rows = F, 
         cluster_cols = F, 
         show_rownames = T, 
         show_colnames = T, 
         color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(breaksList2)), # Defines the vector of colors for the legend (it has to be of the same lenght of breaksList) 
         breaks = breaksList2) # Sets the breaks of the color scale as in breaksList)
dev.off()
```



#####boxplot supplements

```{r boxplots}
#boxplot to supplement - comparing 600 GWAS gene list vs 50
#genes that are functionally validated (smaller list) should get better scores than the larger list (i.e., if we look at an enriched set, we should get more functional association)

IBDsmall <- read_excel("/Users/montanalara/Documents/R\ Mattslab/archive/IBDsmall/Data/mmc6.xlsx", sheet = "putative_risk_genes")

# convert human to mouse genes using gprofiler
IBDGWASsmallMousegenes <- gorth(IBDsmall[[1]], source_organism = "hsapiens", target_organism = "mmusculus")
# convert mouse genes to entrez IDs
IBDGWASsmallMouseEntrez <- gconvert(IBDGWASsmallMousegenes[["target.name"]], organism = "mmusculus", target = "ENTREZGENE_ACC")
#separate out entrez ID from the "entrez acc" part
IBDGWASsmallMouseEntrez <- separate(IBDGWASsmallMouseEntrez, target, c("eID", "entrez ID"), sep = ":")


#find smaller list and bigger list
# PROBLEM - but this is somewhat hard to do because these don't just come from chr 1 and 2, so the lists get cut WAY down and can't actually compare them
IBDsmall.final.tableTRANS <- filter(final.tableTRANS, entrezgene %in% IBDGWASsmallMouseEntrez$`entrez ID`)
IBDbig.final.tableTrans <- filter(final.tableTRANS, entrezgene %in% IBDGWASmouseEntrez$`entrez ID`)
boxplot(IBDbig.final.tableTrans$Mean.FP.Rate, IBDsmall.final.tableTRANS$Mean.FP.Rate)
#but at least comparing both the small and big (that have scores from chr 1 and 2) to the total of the final.table - those have better scores than the total
boxplot(final.tableTRANS$Mean.FP.Rate, IBDsmall.final.tableTRANS$Mean.FP.Rate)
boxplot(final.tableTRANS$Mean.FP.Rate, IBDbig.final.tableTrans$Mean.FP.Rate)
```







#### Chromosome 12



```{r chr 12 genes}
#using Ccc1 locus
chr12Ccc1 <- read_excel("/Users/montanalara/Documents/MATTS LAB/IBD/Ccc1 locus genes.xlsx")
#have to: get entrez IDs, copy results to be able to use, check entrez id list, then run score.candidates...
#score.candidates(results6.dir, candidate.genes = as.character(DEGapc[["Entrez_Gene_ID"]]))


mus <- useEnsembl(biomart="ensembl", dataset="mmusculus_gene_ensembl") #most recent version

chr <- 12
region.min <- 94800000
region.max <- 112300000
chr.region <- paste(chr, region.min, region.max, sep = ":")

#get position information for all genes in the region
gene.info <- getBM(c("external_gene_name", "entrezgene_id", "start_position", "end_position"), 
                   "chromosomal_region", values = chr.region, mart = mus)

qtl.entrez <- gene.info[!is.na(gene.info$entrezgene_id), "entrezgene_id"]
qtl.gene <- gene.info[!is.na(gene.info$entrezgene_id), "external_gene_name"]

```


```{r SVM with chr 12}
#resultsCH12.dir put in the beginning with the others
score.candidates(resultsCH12.dir, candidate.genes = as.character(qtl.entrez))

module.dir <- get.module.dir(resultsCH12.dir)
include_graphics(normalizePath(paste0(module.dir[1], "/Candidate.Gene.SVM.Scores.jpg")))
include_graphics(normalizePath(paste0(module.dir[1], "/Candidate.Gene.FP.Rates.jpg")))
```

```{r chr 12 plot}

#first have to create a column called entrezgene because the function merge.svm.gene.info requires this column name, but i didn't want to change the original entrez id column name because we used that previously for the SVM scores
gene.info$entrezgene <- as.character(gene.info$entrezgene_id)


merge.svm.gene.info.NEWFORCH12(resultsCH12.dir, gene.info)
include_graphics(paste0(module.dir[1], "/Candidate.Gene.SVM.Results.jpg"))

final.tableCH12 <- read.csv("/Users/montanalara/Documents/R\ Mattslab/IBD/ResultsCH12/IBDGWAS/Module1/Candidate.Gene.Results.csv", sep = ",", header = TRUE, stringsAsFactors = FALSE)

final.tableCH12$log10FP <- -log10(final.tableCH12$Mean.FP.Rate)
final.tableCH12$log10FPsc <- final.tableCH12$log10FP/max(final.tableCH12$log10FP)
final.tableCH12$mean.gene.position <- rowMeans(final.tableCH12[c("start_position", "end_position")])

ggplot(final.tableCH12, 
       aes(x = mean.gene.position, 
           y = log10FPsc, 
           label = external_gene_name)) + 
       geom_text(aes(x = mean.gene.position, y = log10FPsc, label= external_gene_name))

ggsave("CHR12_log10plotIBD.svg", height = 10, width = 10, units = "in")

```


